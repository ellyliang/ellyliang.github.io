<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0">
  <channel>
    <title>useLess</title>
    <link>http://www.useLessblog.cn</link>
    <description>useLess - 前端开发</description>
    <lastBuildDate>Sat, 15 Mar 2014 00:00:00 +0800</lastBuildDate>
    <generator>Solo 2.0</generator>
    <item>
      <title>Javascript 对象</title>
      <link>http://www.useLessblog.cn/article/object.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/object.html</guid>
      <pubDate>Sat, 15 Mar 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <ul>
<li>JS简单类型：数字、字符串、布尔值（true 和 false）、null值和undefined值。</li>
<li>其他所有值都是对象。</li>
<li>数组是对象，函数是对象，正则表达式是对象，当然，对象也是对象。</li>
<li>Prototype(原型链)：允许对象继承另一个对象的属性。正确的使用它，能减少对象初始化时消耗的时间和内存。</li>
</ul>

<h3>对象字面量</h3>

<blockquote>
  <ul>
  <li>对象字面量提供了一种非常方便的创建新对象值得表示法。</li>
  <li>对象字面量就是包围在一对花括号中的零或多个“名/值” 对。</li>
  <li>对象字面量出现在任何允许表达式出现的地方</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var empty_obj = {};

var stooge = {
    'first_name' : 'cm',
    'last_name' : 'liang'
};
</code></pre>

<blockquote>
  <ul>
  <li>属性名可以是包括空字符串在内的任何字符串；</li>
  <li>在字面量中，如果属性名是一个合法的JS标识且不是保留字，则并不强求用引号括住属性名；</li>
  <li>逗号是用来分隔多个“名/值”对；</li>
  <li>属性值可以从包括另一个对象字面量在内的任意表达式中获得。</li>
  </ul>
</blockquote>

<pre><code>var flight = {
    airline: 'Oceanic',
    number: 815,
    departure: {
        IATA: 'SYD',
        time: '2014-01-01',
        city: 'GZ'
    },
    arrival: {
        IATA: 'LAX',
        time: '2013-01-01',
        city: 'SZ'
    }
};
</code></pre>

<h3>检索</h3>

<blockquote>
  <ul>
  <li>检索对象中包含的值，有两种方式：
  <ul><li>1.在[]后缀中括住一个字符串表达式的方式。</li>
  <li>2.<strong>优先考虑的方法</strong>，使用 . 表示法，它更紧凑且可读性更好。</li></ul></li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>stooge['first_name']; //cm
flight.arrival.city; //SZ
</code></pre>

<blockquote>
  <ul>
  <li>检索一个不存在的成员元素的值，返回“undefined”。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>stooge['middle_name']; //undefined
flight.goWhere; //undefined
</code></pre>

<blockquote>
  <ul>
  <li>||用来填充默认值</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var middle = stooge['middle_name'] || '(none)';
middle; //"(none)"

var status = flight.status || 'unknown';
status;   //unknown
</code></pre>

<blockquote>
  <ul>
  <li>检索一个undefined值会导致TypeError异常。可以通过&amp;&amp;运算符来避免错误。</li>
  </ul>
</blockquote>

<pre><code>stooge.address; //undefined
stooge.address.language; //throw "TypeError"
stooge.address &amp;&amp; stooge.address.language; //undefined
</code></pre>

<h3>更新</h3>

<blockquote>
  <ul>
  <li>对象中的值可以通过赋值语句来更新。</li>
  <li>如果属性名已经存在对象中，那个这个属性值会被替换。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>stooge.first_name = "elly";
stooge.first_name; //"elly"
</code></pre>

<blockquote>
  <ul>
  <li>如果对象中没有那个属性名，那么该属性就被扩充到该对象中。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>empty_obj.nickname = 'John';
empty_obj.nickname; //"John"

flight.equipment = {
    model: 'MH370'
};
flight.equipment.model;  //"MH370"
</code></pre>

<h3>引用</h3>

<blockquote>
  <ul>
  <li>对象通过引用来传递，永远不会被拷贝。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var x = empty_obj;  //将x赋值给empty_obj对象
x.hobby = 'movie';
var hob = empty_obj.hobby; //"movie"
//or var hob = x.hobby; //"movie"
</code></pre>

<blockquote>
  <ul>
  <li>x和empty<em>obj是指向同一个对象的引用，所以x.hobby 和 empty</em>obj.hobby为"movie"。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var a={},b={},c={};
//a、b和c都引用一个不同的空对象

a = b = c = {};
//a、b和c都是引用同一个空对象
</code></pre>

<h3>原型</h3>

<blockquote>
  <ul>
  <li>每个对象都连接到一个原型对象，并且它可以从中继承属性。</li>
  <li>所有通过对象字面量创建的对象都连接到Object.prototype这个JS中标准的对象。</li>
  <li>当你创建一个新对象时，可以选择某个对象作为它的原型。</li>
  <li>原型连接在更新时是不起作用的。当对某个对象做出改变时，不会触及到该对象的原型。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var stooge = {
    nickname: 'elly'
};
if(typeof Object.beget !== 'function'){
    Object.beget = function(o){
        var F = function(){};
        F.prototype = o;
        return new F();
    };
}

var another_stooge = Object.beget(stooge);
another_stooge.nickname = 'cm';
stooge.nickname; //"elly"
another_stooge.nickname;  //"cm"
</code></pre>

<blockquote>
  <ul>
  <li>原型连接只有在检索值的时候才被用到。</li>
  <li>如果我们尝试去获取对象的某个属性值，且该对象没有此属性名，那么JS会尝试从原型对象中获取属性值。</li>
  <li>如果那个原型对象也没有该属性，那么再从它的原型中寻找，依次类推，知道该过程最后到达终点Object.prototype。</li>
  <li>如果想要的属性完全不存在于原型链中，那么结果就是undefined。</li>
  <li>这个过程称为<strong>委托</strong></li>
  </ul>
</blockquote>

<p>上面那5句话第一次接触原型的朋友，应该不好理解，下面给个例子参考(PS:也是别人给我解释的，谢谢@basecss)：</p>

<pre><code>function Person(name,age) {
    this.name = name;
    this.age = age;
    //......
}
var useLess = new Person('useLess', 23);

// 注意下面
useLess.job; // undefined
// 首先 useLess 自身没有job属性
// 那就到 Person.prototype 中看看，还是没有
// 再到 Object 原型中找，还是没有
// 返回 undefined
useLess.toString(); // ['object Object']
// useLess 自己没有 toString() 方法
// 找它的原型 Person.prototype ，木有

最后到 Object.prototype 找到 toString() 方法
</code></pre>

<blockquote>
  <ul>
  <li>原型关系是一种动态的关系。</li>
  <li>如果我们添加一个新的属性在原型中，该属性会立即对所有基于该原型创建的对象可见。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>stooge.profession = 'actor';
another_stooge.profession; //'actor'
</code></pre>

<h3>反射</h3>

<blockquote>
  <ul>
  <li>检查对象并确定对象的属性，只要试着去检索该属性并验证取得的值。</li>
  <li>typeof可以确定属性的类型</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>typeof stooge.profession; //'string'
</code></pre>

<blockquote>
  <ul>
  <li>请务必注意，原型链中的任何属性也会产生一个值</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>typeof flight.toString; //'function'
typeof flight.constructor; //'function'
</code></pre>

<blockquote>
  <ul>
  <li>有两种方法处理这些不需要的属性
  <ul><li>第一个是让你的程序检查并剔除函数值</li>
  <li>第二个是使用hasOwnProperty方法。注意：如果对象拥有独有的属性，它将返回true。hasOwnProperty方法不会检查原型链</li></ul></li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>flight.hasOwnProperty('number');  //true
flight.hasOwnProperty('constructor'); //false
</code></pre>

<h3>枚举(for in)</h3>

<blockquote>
  <ul>
  <li>for in语句可用来遍历一个对象中的所有属性名。</li>
  <li>枚举过程将会列出所有的属性，包括函数和你可能不关心的原型中的属性,所以有必要多虑掉那些你不想要的值。</li>
  <li>最常用的过滤器是hasOwnProperty方法，以及使用typeof来排除函数。</li>
  </ul>
</blockquote>

<p>例如： </p>

<pre><code>var name;
for(name in another_stooge){
    if(typeof another_stooge[name] !== 'function'){
        document.writeln(name + ':' + another_stooge[name]);
    }
}
</code></pre>

<blockquote>
  <ul>
  <li>for in语句陈列出来的属性名顺序是不确定的，如果你想让属性名按顺序出现，最好的办法就是避免使用for in语句。</li>
  <li>而是创建一个数组，在其中以正确的顺序包含属性名。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var i;
var properties = {
    'first_name',
    'profession'

};
for(i = 0; i &lt; properties.length; i += 1){
    document.writeln(properties[i] + ':' + another_stooge[properties[i]]);
}
</code></pre>

<blockquote>
  <ul>
  <li>使用for,可以得到我们想要的属性，不用担心可能发掘出原型链中的属性，并且按顺序取得了它们的值。</li>
  </ul>
</blockquote>

<h3>删除(delete)</h3>

<blockquote>
  <ul>
  <li>delete运算符用来删除对象的属性，它不会触及原型链中的任何对象。</li>
  </ul>
</blockquote>

<pre><code>another_stooge.nickname; //'cm' 
delete another_stooge.nickname;
another_stooge.nickname; //暴露出原型中nickname属性。'elly'
</code></pre>

<h3>减少全局变量污染</h3>

<blockquote>
  <ul>
  <li>全局变量削弱程序的灵活性，所以尽量避免。</li>
  <li>最小化用全局变量的一个方法是在你的应用中只创建唯一一个全局变量。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var MYAPP = {};
//此时，全局变量已经变成了你的容器
MYAPP.stooge = {
    'first_name' : 'cm',
    'last_name' : 'liang'
};

MYAPP.flight = {
    'airline' : 'Oceanic',
};
</code></pre>

<blockquote>
  <ul>
  <li>只要把多个全局变量都整理在一个名称空间下，你将显著降低与其他应用程序、组件或类库之间产生糟糕的相互影响的可能性。</li>
  <li>你的程序也会变得更容易阅读。</li>
  </ul>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>如何用toosolo建静态博客</title>
      <link>http://www.useLessblog.cn/article/toosolo.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/toosolo.html</guid>
      <pubDate>Fri, 07 Mar 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>在创建博客之前，你是不是忘了一件事呢？是的，你需要一个域名。你是不是现在立刻去万网之类的网站购买域名？先不要着急，这里提供两种方法给你选择，一种是你可以买了域名之后绑定到github page上面，就不需要去备案啥的。另一种是直接用github page上面的域名，例如：username.github.io。是不是不知道怎么操作，没事，你可以看 <a href="http://littledu.net/article/how-to-use-github.html">这里</a>。另外，建议你在买域名之前先看<a href="http://www.zhihu.com/question/20556410">这篇文章</a>。</p>

<p>言归正传，首先你先到<a href="https://github.com/TooBug/TooSolo">这里</a>了解Toosolo。是的，他里面也有教程，但是我还是要写这篇文章，至于问为什么，我也不知道。我只知道我写的唯一优势就是配了图说明。废话不多说，马上开始学习：</p>

<p>第一步：到<a href="http://nodejs.org/">node官网</a>下载node,然后安装。你是不是想问，为什么要安装node,很明显，你没有认真看github里面的内容。答案就是：<strong>Toosolo 是一个由Node构建的静态博客</strong>(PS：这一步就不配图详说了，有人跟我说，会装QQ的人都会装node。T^T)</p>

<p>第二步：安装Toosolo。</p>

<blockquote>
  <ul>
  <li><strong>windows + R</strong>输入<strong>cmd</strong>打开控制台;</li>
  <li>输入<strong>npm install -g toosolo</strong>执行命令。</li>
  <li>如果出现下图，恭喜你，说明你安装成功了！</li>
  </ul>
</blockquote>

<p><img src="/images/solo1.jpg" alt="Toosolo" title="" /></p>

<p>第三步：初始化Toosolo。</p>

<blockquote>
  <ul>
  <li>在你喜欢的磁盘中建个空文件夹;</li>
  <li>输入<strong>toosolo --init</strong> 或<strong> toosolo -i</strong>;</li>
  <li>如果你建的文件夹中有个source文件夹和config.json的文件，那么，恭喜你，初始化成功！</li>
  </ul>
</blockquote>

<p><img src="/images/solo2.jpg" alt="Toosolo" title="" /></p>

<p>初始化之后，里面文件夹及文件说明如下图：</p>

<p><img src="/images/solo3.jpg" alt="Toosolo" title="" /></p>

<p>第四步：编译toosolo。</p>

<blockquote>
  <ul>
  <li>在你每次修改toosolo里面的任何文件之后;</li>
  <li>定位到config.json所在的目录，然后执行toosolo这个命令;</li>
  <li>然后你会在你建的文件夹中看到一个dist文件夹</li>
  </ul>
</blockquote>

<p>额外知识：</p>

<pre><code>    D:  -&gt; 进入盘符
    dir  -&gt; 查看目录
    cd xxx -&gt; 进入 xxx 目录
    cd ../ -&gt; 回退到上层目录
</code></pre>

<p><img src="/images/solo4.jpg" alt="Toosolo" title="" /></p>

<p>第五步：然后在dist文件夹中打开index.html，就可以看到toosolo的模板了！</p>

<p>哈哈，执行到这里，就不用步骤形容了。</p>

<h3>接下来的问题是：如何将toosolo放到你的域名中展示呢？</h3>

<p>很简单，你只需将dist文件夹里面的文件复制你的空间中就行，然后修改config.json中的distPath。如图：</p>

<p><img src="/images/solo5.jpg" alt="Toosolo" title="" /></p>

<p>如果你是用github page的域名或是将你自己的域名绑定到github page，你可以按<a href="http://littledu.net/article/how-to-use-github.html">这里</a>的步骤去做。</p>

<p>注意，如果是将绑定自己的域名到github page，记得修改source/global/CNAME为自己的域名，不然每次commit的时候都会变回原来的。如图：</p>

<p><img src="/images/solo6.jpg" alt="Toosolo" title="" /></p>

<h3>看到这里，你是不是还有个疑问，如果我想改里面的排版或是样式要在哪里改？</h3>

<blockquote>
  <ul>
  <li>执行这个命令：<strong>toosolo --skin</strong>或是<strong>toosolo -s</strong>;</li>
  <li>你会在./source目录下看到有个skin的文件夹。</li>
  </ul>
</blockquote>

<p>如图：</p>

<p><img src="/images/solo7.jpg" alt="Toosolo" title="" /></p>

<p>skin里面文件夹介绍如图：</p>

<p><img src="/images/solo8.jpg" alt="Toosolo" title="" /></p>

<p>提醒：里面涉及到了使用jade。当然，要想发博客，你要先知道markdown（哈哈，这句貌似应该是在最前面提的，不管了）。你可以通过以下的链接进行了解：</p>

<blockquote>
  <ul>
  <li><p>了解markdown链接如下：
  <a href="https://www.zybuluo.com/mdeditor">https://www.zybuluo.com/mdeditor</a>
  <a href="http://wowubuntu.com/markdown/">http://wowubuntu.com/markdown/</a></p></li>
  <li><p>了解jade链接如下：
  <a href="http://naltatis.github.io/jade-syntax-docs/">http://naltatis.github.io/jade-syntax-docs/</a></p></li>
  </ul>
</blockquote>

<h3>还有一个问题，我要在哪里写我要发表的文章呢？</h3>

<p>看图说话：</p>

<p><img src="/images/solo9.jpg" alt="Toosolo" title="" /></p>

<h3>最后一个问题，页面上的图片要放在哪呢？图片怎么在本地看不到呢？</h3>

<blockquote>
  <ul>
  <li>页面上的图片放在/source/global/images目录下</li>
  <li>图片要推到外网之后才能看到，这个不用担心。</li>
  </ul>
</blockquote>

<p>哈哈，还有什么问题，可以在评论中提出来的哈。。。。。。</p>

<p>参考：</p>

<blockquote>
  <ul>
  <li><a href="https://github.com/TooBug/TooSolo">https://github.com/TooBug/TooSolo</a></li>
  <li><a href="https://github.com/TooBug/TooSolo/issues/17">https://github.com/TooBug/TooSolo/issues/17</a></li>
  <li><a href="https://github.com/TooBug/TooSolo/issues/21">https://github.com/TooBug/TooSolo/issues/21</a></li>
  </ul>
</blockquote>
        ]]>
      </description>
    </item>
  </channel>
</rss>