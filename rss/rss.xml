<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0">
  <channel>
    <title>useLess</title>
    <link>http://www.useLessblog.cn</link>
    <description>useLess - 前端开发</description>
    <lastBuildDate>Thu, 12 Jun 2014 00:00:00 +0800</lastBuildDate>
    <generator>Solo 2.0</generator>
    <item>
      <title>css3之很丑的蜗牛</title>
      <link>http://www.useLessblog.cn/article/snail.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/snail.html</guid>
      <pubDate>Thu, 12 Jun 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>嗯，这个“很丑的蜗牛”由来是因为腾讯一位女程序媛的“一个红点的故事”而且产生的。想看她一个元素做出来的叮当？请看最后的链接！不过，确切来说，自己想通过这只不太像蜗牛的蜗牛学习下css3，哈哈哈哈....</p>

<p><img src="/images/snail.png" alt="Snail" title="" />;</p>

<h3>代码如下</h3>

<p>HTML:</p>

<pre><code>&lt;div class="snail"&gt;
    &lt;div class="snail-body"&gt;&lt;/div&gt;
    &lt;div class="snail-tail"&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>

<p>CSS:</p>

<pre><code>body {
    width: 100%;
    height: 100%;
    background: #66cd99;
    overflow: hidden;
}
@keyframes snailRun {
    from {
        right: 0;
    }
    to {
        left: -100px;
    }
}
/*firefox*/
@-moz-keyframes snailRun {
    from {
        right: 0;
    }
    to {
        left: 100px;
    }
}
/*chrome*/
@-webkit-keyframes snailRun {
    from {
        right: 0;
    }
    to {
        left: -100px;
    }
}

/*opera*/
@-o-keyframes snailRun {
    from {
        right: 0;
    }
    to {
        left: -100px;
    }
}
.snail {
    -webkit-animation: 25s linear infinite snailRun;
       -moz-animation: 25s linear infinite snailRun;
         -o-animation: 25s linear infinite snailRun;
            animation: 25s linear infinite snailRun;
}
.snail {
    position: relative;
    left: 1500px;
    width: 100px;
    height: 100px;
    margin-top: 300px;
    border-radius: 50%;
    box-shadow: 0px 0px 0 2px #666;
    background: #fe9b00;
}
.snail:before {
    content: '';
    position: absolute;
    left: 16%;
    top: 16%;
    width: 70px;
    height: 70px;
    border-radius: 50%;
    box-shadow: 0px 0px 0 2px #666;
    background: #fe9b00;
}
.snail:after {
    content: '';
    position: absolute;
    left: 31%;
    top: 31%;
    width: 40px;
    height: 40px;
    border-radius: 50%;
    box-shadow: 0px 0px 0 2px #666;
    background: #fe9b00;
}

.snail-body {
    position: relative;
    left: -37px;
    top: 22px;
    width: 35px;
    height: 35px;
    border-radius: 50%;
    box-shadow: 0px 0px 0 1px #fff, -33px 15px 0 -15px #333333, -34px 15px 0 1.5px #fff;
    background: #fff;
}
.snail-body:before {
    content: '';
    position: absolute;
    left: 15px;
    top: 15px;
    width: 5px;
    height: 5px;
    border-radius: 50%;
    background: #000;
}
.snail-tail {
    position: absolute;
    top: 102px;
    width: 100px;
    height: 20px;
    background: #fef0bc;
    border-top-left-radius: 60px 90px;
    border-bottom-right-radius: 120px 90px;
}
.snail-tail:before {
    content: '';
    position: absolute;
    top: -53px;
    left: -17px;
    width: 27px;
    height: 80px;
    background: #fef0bc;
    border-top-left-radius: 90px 0px;
    border-bottom-right-radius: 120px 0px;
    border-top-right-radius: 120px 90px;
    border-bottom-left-radius: 120px 90px;
    -moz-transform: rotate(45deg);
    -webkit-transform: rotate(140deg);
    -o-transform: rotate(45deg);
    -ms-transform: rotate(45deg);
    transform: rotate(45deg);      
}
</code></pre>

<p>链接：</p>

<blockquote>
  <ul>
  <li><a href="http://pigrun.github.io/1st_run/demos/pping/pokonyan/pokonyan.html">一个小红点的故事</a></li>
  <li><a href="https://github.com/ellyliang/Note/blob/master/html&amp;css/css3Slide/snail.html">很丑蜗牛</a></li>
  </ul>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>Javascript作用域&amp;提升-笔记</title>
      <link>http://www.useLessblog.cn/article/scoping&amp;hoisting.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/scoping&amp;hoisting.html</guid>
      <pubDate>Sat, 26 Apr 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>为什么第一个会报错，而第二个没报错，你造吗？不造？好的，接下来我们就一起学习以下的笔记，学完之后你就造了！哈哈......</p>

<pre><code>useLess();  //TypeError: undefined is not a function
var useLess = function(){
    alert(2);
};

useLess(); //2
function useLess(){
    alert(2);
}
</code></pre>

<h3>Note1--Javascript拥有2种作用域：全局作用域和函数作用域。在Javascript中的块（例如：if-else）不会创建新的作用域，函数才会创建新的作用域。</h3>

<p>栗子：</p>

<pre><code>var name = "useLess";
console.log(name); //"useLess"
if(true){
    console.log(name); //"useLess"
    var name = "ellyLiang"; 
    console.log(name); //"ellyLiang"
}
console.log(name); //"ellyLiang"
</code></pre>

<h3>Note2--如果想在Javascript中创建一个临时作用域，可用即时函数。</h3>

<p>栗子：</p>

<pre><code>var name = "useLess";
if(true){
    (function(){
        var name="ellyLiang";
        console.log(name); //"ellyLiang"
    }());
    console.log(name); //"useLess"
}
console.log(name); //"useLess"
</code></pre>

<h3>Note3--使用var声明的变量名会提升到作用域的顶端，函数声明也会提升。</h3>

<p>栗子：</p>

<pre><code>function blog(){
    func();
    var name = "www.useLessblog.cn";
}
</code></pre>

<p>被解释为：</p>

<pre><code>function blog(){
    var name;
    func();
    name = "www.useLessblog.cn";
}
</code></pre>

<h3>Note4--有一种情况，声明所在的语句不执行，但是不影响提升的机制。</h3>

<p>栗子：</p>

<pre><code>function blog(){
    if(false){
        var name = "www.useLessblog.cn";
    }
    return;   //中断
    var github = "ellyLiang";  //不执行
}
</code></pre>

<p>与上面blog函数等效：</p>

<pre><code>function blog(){
    var name, github;
    if(false){
        name = "www.useLessblog.cn";
    }
    return; //中断
    github = "ellyLiang"; //不执行
}
</code></pre>

<h3>Note5--声明和赋值一起写，但是赋值不会被提升，只有变量名被提升到函数顶部。函数声明，整个函数名和函数体都会被提升。</h3>

<p>栗子：</p>

<pre><code>function me(){
    blog();  //Uncaught TypeError: undefined is not a function 
    useLess();  //"Yes, useLess is a Woman man!" 

    var blog = function(){  //函数表达式（PS：blog普通变量，然后把函数赋值给blog，因此blog这个变量名被提升，而函数部分未被提升。）
        console.log("www.useLessblog.cn");
    };

    function useLess(){    //完整的函数声明
        console.log("Yes, useLess is a Woman man!");
    }
}
me();
</code></pre>

<p>注：useLess函数声明的函数体被提升了；blog变量名被提升，但是函数部分未被提升！</p>

<h3>Note6--变量识别顺序</h3>

<p>如果一个变量已经被定义了，它就不会被另一个相同名字的变量覆盖，这意味着函数声明比函数变量声明有更高的优先级。但是不影响对这个变量赋值的继续运行，只是声明会被忽略。</p>

<p>栗子：</p>

<pre><code>function useLess(){}
var useLess = "Yes,useLess is a Woman man!";
console.log(useLess); //"Yes,useLess is a Woman man!"
</code></pre>

<p>被解释为：</p>

<pre><code>function useLess(){}
//var useLess; //会被忽略掉
useLess = "Yes,useLess is a Woman man!";
console.log(useLess); //"Yes,useLess is a Woman man!"
</code></pre>

<h3>Note7--带有名字的函数表达式->可以给函数表达式起个名字，采用函数声明的语法，但不能使它成为一个函数声明，函数体也不会被提升。</h3>

<p>栗子：</p>

<pre><code>blog(); //Uncaught TypeError: Property 'blog' of object [object Object] is not a function 
useLess(); //Uncaught ReferenceError: useLess is not defined 

var blog = function useLess(){};
</code></pre>

<h3>最后总结：</h3>

<p>总是使用var声明变量，强烈建议在每个作用域顶部写一个var语句，这么做，就不会遇到提升相关的困惑了！
哈哈~看完明白上面那2个函数的区别了么，还是不明白？好吧，建议去翻译笔主的博客学习！链接在下面！灰常
感谢<a href="http://www.basecss.net">@basecss</a>提供的信息和指导！这篇笔记如有错误的地方，欢迎大家指正，同时，我会继续学习作用域，然后再修改这篇笔记，希望大家多指导！大家有兴趣交流JS，可以加入JS交流群：365143137！</p>

<p>参考：</p>

<blockquote>
  <ul>
  <li><a href="http://octsky.com/post/65/">http://octsky.com/post/65/</a></li>
  </ul>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>Grunt安装过程</title>
      <link>http://www.useLessblog.cn/article/install-grunt.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/install-grunt.html</guid>
      <pubDate>Fri, 28 Mar 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>Grunt是啥么？可以到<a href="http://www.gruntjs.org/">Grunt中文社区</a>了解。
哈哈，是的，我是一名前端菜鸟，一开始不知道Grunt是什么，也不知道Grunt可以做什么，而且进入到官网看的时候，还是不大明白，但是到你按官网的里面步骤走一遍的时候，你就会初步知道grunt的作用。</p>

<p>当然，你要安装grunt,首先你要安装nodejs。可以到<a href="http://nodejs.org/">node官网</a>下载安装包，跟第一篇博客一样，不讲解node的安装过程。</p>

<p>下面是Grunt安装过程图文讲解：</p>

<h3>第一步：安装全局的Grunt cli。</h3>

<p>执行命令：</p>

<pre><code>npm install -g grunt-cli
</code></pre>

<p>如下图，恭喜你安装成功！</p>

<p><img src="/images/grunt1.jpg" alt="Grunt" title="" />;</p>

<h3>第二步：自动创建package.json。(PS:你也可以手动创建，参考<a href="http://www.gruntjs.org/docs/getting-started.html">Grunt官网的新手上路</a>)</h3>

<p>执行命令：</p>

<pre><code>npm init
</code></pre>

<p>如下图，恭喜创建成功！</p>

<p><img src="/images/grunt2.jpg" alt="Grunt" title="" />;</p>

<h3>第三步：本地安装&lt; module >（PS:安装插件到当前目录 同时生成依赖)</h3>

<p>执行命令：</p>

<pre><code>npm install module --save-dev
</code></pre>

<p>如下图，恭喜安装成功！</p>

<p><img src="/images/grunt3.jpg" alt="Grunt" title="" />;</p>

<h3>第四步：安装Grunt到你的项目中</h3>

<p>执行命令：</p>

<pre><code>npm install grunt --save-dev
</code></pre>

<p>如下图，恭喜安装成功！</p>

<p><img src="/images/grunt4.jpg" alt="Grunt" title="" />;</p>

<p>note: 这步安装的时候，npm可能会抽风（就是停在那里不动），建议安装个cnpm,详细可看<a href="http://cnpmjs.org/">cnpmjs.org</a>,安装完成之后，跟你之前一样运行你的命令。</p>

<p>安装cnpm的命令：</p>

<pre><code>npm install -g -cnpm --register-http://r.cnpmjs.org
</code></pre>

<h3>第五步：配置和插件（Gruntfile.js）(PS:哈哈，我个人感觉，安装过程简单，但是配置过程难)。</h3>

<blockquote>
  <ul>
  <li>在你的项目中建一个gruntfile.js文件。</li>
  <li>gruntfile.js通用写法如下：</li>
  </ul>
</blockquote>

<pre><code>module.exports = function(grunt) {
    grunt.initConfig({
        pkg: grunt.file.readJSON('package.json');
    });
};
</code></pre>

<blockquote>
  <ul>
  <li>添加grunt uglify(压缩)插件，当然还有很多插件，例如grunt LESS、grunt Jshint、grunt concat等等，具体自己google，这里我就简单演示grunt uglify和grunt watch。</li>
  </ul>
</blockquote>

<ul>
<li>首先，你要先下载grunt uglify。</li>
</ul>

<p>执行命令：</p>

<pre><code>npm install grunt-contrib-uglify
</code></pre>

<p>如下图，恭喜下载成功！</p>

<p><img src="/images/grunt5.jpg" alt="Grunt" title="" />;</p>

<p>然后gruntfile.js配置:</p>

<pre><code>module.exports = function(grunt) {
    grunt.initConfig({
        pkg: grunt.file.readJSON('package.json'),

        uglify: {
            default: {
                files: [{
                    expand: true,
                    cwd: 'JS/',     //源目录
                    src: '**/*.js',    //源文件后缀
                    dest: 'minJS/',   //目标目录
                    ext: '.min.js'    //生成文件的后缀
                }]
            }
        }
    });

    //任务加载
    grunt.loadNpmTasks('grunt-contrib-uglify');

    //任务自定义
    grunt.registerTask('default', ['uglify']);
};   
</code></pre>

<p>配置完成后，执行grunt命令,如下图：</p>

<p><img src="/images/grunt6.jpg" alt="Grunt" title="" />;</p>

<pre><code>PS:
    grunt -&gt; 执行默认任务
    grunt taskname -&gt; 执行指定任务
</code></pre>

<p>然后你会看到minJS生成一个了的压缩的useLess.min.js,如图：</p>

<p><img src="/images/grunt7.jpg" alt="Grunt" title="" />;</p>

<p>我的目录结构：</p>

<pre><code>——test
  |__JS
     |__useLess.js
  |__minJS

//当执行完grunt后，minJS中会生成个useLess.min.js。
</code></pre>

<blockquote>
  <ol>
  <li>添加grunt watch(自动化)插件</li>
  </ol>
</blockquote>

<p>运行命令：</p>

<pre><code>npm install grunt-contrib-watch
</code></pre>

<p>这步就不配下载成功的图了。</p>

<p>在gruntfile.js中添加任务：</p>

<pre><code>module.exports = function(grunt) {
    grunt.initConfig({
        pkg: grunt.file.readJSON('package.json'),

        uglify: {
            default: {
                files: [{
                    expand: true,
                    cwd: 'JS/',     //源目录
                    src: '**/*.js',    //源文件后缀
                    dest: 'minJS/',   //目标目录
                    ext: '.min.js'    //生成文件的后缀
                }]
            }
        },
        watch: {
            scripts: {
                files: ['**/*.js'],
                tasks: ['uglify'],
                options: {
                    spawn: false,
                },
            }
        }
    });

    //任务加载
    grunt.loadNpmTasks('grunt-contrib-uglify');
    grunt.loadNpmTasks('grunt-contrib-watch');

    //任务自定义
    grunt.registerTask('default', ['uglify', 'watch']);
};
</code></pre>

<p>grunt watch在你每次修改useLess.js的时候，都会自动帮你压缩，不用每次都要执行grunt命令，如图：</p>

<p>没修改useLess.js之前：</p>

<p><img src="/images/grunt8.jpg" alt="Grunt" title="" />;</p>

<p>修改useLess.js之后，自动压缩useLess.js成useLess.min.js：</p>

<p><img src="/images/grunt9.jpg" alt="Grunt" title="" />;</p>

<p>如果你想安装非全局的grunt，看<a href="http://www.basecss.net/article/using-grunt-in-local.html">这里</a>。</p>

<p>哈哈，你照着上面5个步骤去做，有没有初步了解了grunt是做什么的了呢？不知道！那就继续看<a href="http://www.gruntjs.org/">grunt官网</a>或是google更多关于grunt的知识，或是看我下面的链接。当然，这篇文章有很多不足的地方，求各位大神指点！当然，感谢那些耐心解答我问题的大牛们，有机会的话，请你们吃M记，嘻嘻。。。！</p>

<p>文章就到此结束鸟。。。。</p>

<p>参考：</p>

<blockquote>
  <ul>
  <li><a href="http://www.gruntjs.org/">http://www.gruntjs.org/</a></li>
  <li><a href="http://docs.spmjs.org/contrib/simple-grunt">http://docs.spmjs.org/contrib/simple-grunt</a></li>
  <li><a href="https://github.com/TVVT/mobile-start">https://github.com/TVVT/mobile-start</a></li>
  <li><a href="http://www.w3cplus.com/tools/grunt-tutorial-installing-grunt.html">http://www.w3cplus.com/tools/grunt-tutorial-installing-grunt.html</a></li>
  <li><a href="http://www.w3cplus.com/tools/automating-your-workflow-with-grunt.html">http://www.w3cplus.com/tools/automating-your-workflow-with-grunt.html</a></li>
  </ul>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>《JS语言精粹》笔记之函数第一部分</title>
      <link>http://www.useLessblog.cn/article/func.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/func.html</guid>
      <pubDate>Sat, 22 Mar 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <ul>
<li>函数包含一组语句，它们是JS的基础模块单元，用于代码复用、信息隐藏和组合调用。</li>
<li>函数用于指定对象的行为。</li>
<li>所谓编程，就是将一组需求分解成一组函数和数据结构的技能。</li>
</ul>

<h3>函数对象</h3>

<blockquote>
  <ul>
  <li>函数就是对象。</li>
  <li>对象字面量产生的对象连接到Object.prototype。</li>
  <li>函数对象连接到Function.prototype(其本身连接到Object.prototype)。</li>
  <li><p>函数在创建时附有两个附加的隐藏属性：函数的上下文和实现函数行为的代码。</p></li>
  <li><p>函数可以保存在变量、对象和数组中。</p></li>
  <li>函数可以被当做参数传递给其他函数，函数也可以返回函数。</li>
  <li>函数是对象，所以函数拥有方法。函数的不同之处是，函数可以被调用。</li>
  </ul>
</blockquote>

<h3>函数字面量</h3>

<blockquote>
  <ul>
  <li>函数包含4个部分：
  *1. 保留字function；
  *2. 函数名，可省略；
  *3. 包围在花括号的一组参数；
  *4. 包围在花括号的一组语句（函数的主体，被调用时执行）。</li>
  <li>一个内部函数除了可以访问自己的参数和变量，也能自由访问把它嵌套在其中的父函数的参数与变量。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var add = function(a, b) {
    return a + b;
};
</code></pre>

<h3>调用</h3>

<blockquote>
  <ul>
  <li>调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。</li>
  <li>除了声明时定义的形式参数，每个函数还接收2个附加的参数：this和arguments（this取决于调用的模式）。</li>
  <li>JS中有4种调用模式：方法调用模式、函数调用模式、构造器调用函数和apply调用模式。</li>
  <li>当实际参数（arguments）的个数与形式参数（parameters）的个数不匹配时，不会导致运行时错误。</li>
  <li>参数值过多时，超出的参数值会被忽略。如果实际参数值过少，缺失的值会被替换为undefined。</li>
  </ul>
</blockquote>

<h3>方法调用</h3>

<p>一个函数被保存为对象的一个属性时，称它为一个方法。</p>

<blockquote>
  <ul>
  <li>一个方法被调用时，this被绑定到该对象。</li>
  <li>方法可以使用this访问自己所属的对象，所以它能从对象中取值或对对象进行修改。</li>
  <li>通过this可取得它们所属对象的上下文的方法称为公共方法。</li>
  </ul>
</blockquote>

<p>例如： 
    var myObject = {
        value: 0,</p>

<pre><code>    increment: function(inc) {   //公共方法
        this.value += typeof inc === 'number' ? inc : 1;
    }
};

myObject.increment();
document.writeln(myObject.value); //1

myObject.increment(2);
document.writeln(myObject.value); //3
</code></pre>

<h3>函数调用模式</h3>

<p>函数调用模式的this被绑定带全局对象，让this变成局部变量的解决办法是var that = this。</p>

<p>例如：
    myObject.double = function() {
        var that = this;  //解决方法</p>

<pre><code>    var helper = function() {
        that.value = add(that.value, that.value);
    };

    helper();
};

//调用
myObject.double();
console.log(myObject.value); //6
</code></pre>

<h3>构造器调用模式</h3>

<p>函数前面带上new调用，那么背地里将会创建一个链接到该函数的prototype成员的新对象,同时this会绑定到这个新对象上。</p>

<pre><code>//创建一个构造函数，带有一个status属性的对象
var Quo = function(string) {
    this.status = string;
};
//增加一个get_status公共方法
Quo.prototype.get_status = function() {
    return this.status;
};
//构造Quo实例
var myQuo = new Quo('confused');
cosole.log(myQuo.get_status()); //"confused"
</code></pre>

<h3>Apply调用模式</h3>

<blockquote>
  <ul>
  <li>apply方法构建一个参数数组传递给调用函数，允许我们选择this值。</li>
  <li>apply方法接收2个参数，1：绑定给this的值，2：参数数组（arguments）。</li>
  </ul>
</blockquote>

<pre><code>//Apply调用模式：构建一个参数数组传递给调用函数。
//构造一个数组，并让它们相加
var array = [3, 4];
var sum = add.apply(null,array); //7

//apply调用模式
//构造一个包含status成员的对象
var statusObject = {
    status: 'A-OK'
};

var status = Quo.prototype.get_status.apply(statusObject); //'A-OK'
</code></pre>

<p>哈哈，笔记待续中。。。。。</p>
        ]]>
      </description>
    </item>
    <item>
      <title>《JS语言精粹》笔记之对象</title>
      <link>http://www.useLessblog.cn/article/object.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/object.html</guid>
      <pubDate>Sat, 15 Mar 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <ul>
<li>JS简单类型：数字、字符串、布尔值（true 和 false）、null值和undefined值。</li>
<li>其他所有值都是对象。</li>
<li>数组是对象，函数是对象，正则表达式是对象，当然，对象也是对象。</li>
<li>Prototype(原型链)：允许对象继承另一个对象的属性。正确的使用它，能减少对象初始化时消耗的时间和内存。</li>
</ul>

<h3>对象字面量</h3>

<blockquote>
  <ul>
  <li>对象字面量提供了一种非常方便的创建新对象值得表示法。</li>
  <li>对象字面量就是包围在一对花括号中的零或多个“名/值” 对。</li>
  <li>对象字面量出现在任何允许表达式出现的地方</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var empty_obj = {};

var stooge = {
    'first_name' : 'cm',
    'last_name' : 'liang'
};
</code></pre>

<blockquote>
  <ul>
  <li>属性名可以是包括空字符串在内的任何字符串；</li>
  <li>在字面量中，如果属性名是一个合法的JS标识且不是保留字，则并不强求用引号括住属性名；</li>
  <li>逗号是用来分隔多个“名/值”对；</li>
  <li>属性值可以从包括另一个对象字面量在内的任意表达式中获得。</li>
  </ul>
</blockquote>

<pre><code>var flight = {
    airline: 'Oceanic',
    number: 815,
    departure: {
        IATA: 'SYD',
        time: '2014-01-01',
        city: 'GZ'
    },
    arrival: {
        IATA: 'LAX',
        time: '2013-01-01',
        city: 'SZ'
    }
};
</code></pre>

<h3>检索</h3>

<blockquote>
  <ul>
  <li>检索对象中包含的值，有两种方式：
  <ul><li>1.在[]后缀中括住一个字符串表达式的方式。</li>
  <li>2.<strong>优先考虑的方法</strong>，使用 . 表示法，它更紧凑且可读性更好。</li></ul></li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>stooge['first_name']; //cm
flight.arrival.city; //SZ
</code></pre>

<blockquote>
  <ul>
  <li>检索一个不存在的成员元素的值，返回“undefined”。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>stooge['middle_name']; //undefined
flight.goWhere; //undefined
</code></pre>

<blockquote>
  <ul>
  <li>||用来填充默认值</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var middle = stooge['middle_name'] || '(none)';
middle; //"(none)"

var status = flight.status || 'unknown';
status;   //unknown
</code></pre>

<blockquote>
  <ul>
  <li>检索一个undefined值会导致TypeError异常。可以通过&amp;&amp;运算符来避免错误。</li>
  </ul>
</blockquote>

<pre><code>stooge.address; //undefined
stooge.address.language; //throw "TypeError"
stooge.address &amp;&amp; stooge.address.language; //undefined
</code></pre>

<h3>更新</h3>

<blockquote>
  <ul>
  <li>对象中的值可以通过赋值语句来更新。</li>
  <li>如果属性名已经存在对象中，那个这个属性值会被替换。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>stooge.first_name = "elly";
stooge.first_name; //"elly"
</code></pre>

<blockquote>
  <ul>
  <li>如果对象中没有那个属性名，那么该属性就被扩充到该对象中。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>empty_obj.nickname = 'John';
empty_obj.nickname; //"John"

flight.equipment = {
    model: 'MH370'
};
flight.equipment.model;  //"MH370"
</code></pre>

<h3>引用</h3>

<blockquote>
  <ul>
  <li>对象通过引用来传递，永远不会被拷贝。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var x = empty_obj;  //将x赋值给empty_obj对象
x.hobby = 'movie';
var hob = empty_obj.hobby; //"movie"
//or var hob = x.hobby; //"movie"
</code></pre>

<blockquote>
  <ul>
  <li>x和empty<em>obj是指向同一个对象的引用，所以x.hobby 和 empty</em>obj.hobby为"movie"。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var a={},b={},c={};
//a、b和c都引用一个不同的空对象

a = b = c = {};
//a、b和c都是引用同一个空对象
</code></pre>

<h3>原型</h3>

<blockquote>
  <ul>
  <li>每个对象都连接到一个原型对象，并且它可以从中继承属性。</li>
  <li>所有通过对象字面量创建的对象都连接到Object.prototype这个JS中标准的对象。</li>
  <li>当你创建一个新对象时，可以选择某个对象作为它的原型。</li>
  <li>原型连接在更新时是不起作用的。当对某个对象做出改变时，不会触及到该对象的原型。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var stooge = {
    nickname: 'elly'
};
if(typeof Object.beget !== 'function'){
    Object.beget = function(o){
        var F = function(){};
        F.prototype = o;
        return new F();
    };
}

var another_stooge = Object.beget(stooge);
another_stooge.nickname = 'cm';
stooge.nickname; //"elly"
another_stooge.nickname;  //"cm"
</code></pre>

<blockquote>
  <ul>
  <li>原型连接只有在检索值的时候才被用到。</li>
  <li>如果我们尝试去获取对象的某个属性值，且该对象没有此属性名，那么JS会尝试从原型对象中获取属性值。</li>
  <li>如果那个原型对象也没有该属性，那么再从它的原型中寻找，依次类推，知道该过程最后到达终点Object.prototype。</li>
  <li>如果想要的属性完全不存在于原型链中，那么结果就是undefined。</li>
  <li>这个过程称为<strong>委托</strong></li>
  </ul>
</blockquote>

<p>上面那5句话第一次接触原型的朋友，应该不好理解，下面给个例子参考(PS:也是别人给我解释的，谢谢@basecss)：</p>

<pre><code>function Person(name,age) {
    this.name = name;
    this.age = age;
    //......
}
var useLess = new Person('useLess', 23);

// 注意下面
useLess.job; // undefined
// 首先 useLess 自身没有job属性
// 那就到 Person.prototype 中看看，还是没有
// 再到 Object 原型中找，还是没有
// 返回 undefined
useLess.toString(); // ['object Object']
// useLess 自己没有 toString() 方法
// 找它的原型 Person.prototype ，木有

最后到 Object.prototype 找到 toString() 方法
</code></pre>

<blockquote>
  <ul>
  <li>原型关系是一种动态的关系。</li>
  <li>如果我们添加一个新的属性在原型中，该属性会立即对所有基于该原型创建的对象可见。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>stooge.profession = 'actor';
another_stooge.profession; //'actor'
</code></pre>

<h3>反射</h3>

<blockquote>
  <ul>
  <li>检查对象并确定对象的属性，只要试着去检索该属性并验证取得的值。</li>
  <li>typeof可以确定属性的类型</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>typeof stooge.profession; //'string'
</code></pre>

<blockquote>
  <ul>
  <li>请务必注意，原型链中的任何属性也会产生一个值</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>typeof flight.toString; //'function'
typeof flight.constructor; //'function'
</code></pre>

<blockquote>
  <ul>
  <li>有两种方法处理这些不需要的属性
  <ul><li>第一个是让你的程序检查并剔除函数值</li>
  <li>第二个是使用hasOwnProperty方法。注意：如果对象拥有独有的属性，它将返回true。hasOwnProperty方法不会检查原型链</li></ul></li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>flight.hasOwnProperty('number');  //true
flight.hasOwnProperty('constructor'); //false
</code></pre>

<h3>枚举(for in)</h3>

<blockquote>
  <ul>
  <li>for in语句可用来遍历一个对象中的所有属性名。</li>
  <li>枚举过程将会列出所有的属性，包括函数和你可能不关心的原型中的属性,所以有必要多虑掉那些你不想要的值。</li>
  <li>最常用的过滤器是hasOwnProperty方法，以及使用typeof来排除函数。</li>
  </ul>
</blockquote>

<p>例如： </p>

<pre><code>var name;
for(name in another_stooge){
    if(typeof another_stooge[name] !== 'function'){
        document.writeln(name + ':' + another_stooge[name]);
    }
}
</code></pre>

<blockquote>
  <ul>
  <li>for in语句陈列出来的属性名顺序是不确定的，如果你想让属性名按顺序出现，最好的办法就是避免使用for in语句。</li>
  <li>而是创建一个数组，在其中以正确的顺序包含属性名。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var i;
var properties = {
    'first_name',
    'profession'

};
for(i = 0; i &lt; properties.length; i += 1){
    document.writeln(properties[i] + ':' + another_stooge[properties[i]]);
}
</code></pre>

<blockquote>
  <ul>
  <li>使用for,可以得到我们想要的属性，不用担心可能发掘出原型链中的属性，并且按顺序取得了它们的值。</li>
  </ul>
</blockquote>

<h3>删除(delete)</h3>

<blockquote>
  <ul>
  <li>delete运算符用来删除对象的属性，它不会触及原型链中的任何对象。</li>
  </ul>
</blockquote>

<pre><code>another_stooge.nickname; //'cm' 
delete another_stooge.nickname;
another_stooge.nickname; //暴露出原型中nickname属性。'elly'
</code></pre>

<h3>减少全局变量污染</h3>

<blockquote>
  <ul>
  <li>全局变量削弱程序的灵活性，所以尽量避免。</li>
  <li>最小化用全局变量的一个方法是在你的应用中只创建唯一一个全局变量。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var MYAPP = {};
//此时，全局变量已经变成了你的容器
MYAPP.stooge = {
    'first_name' : 'cm',
    'last_name' : 'liang'
};

MYAPP.flight = {
    'airline' : 'Oceanic',
};
</code></pre>

<blockquote>
  <ul>
  <li>只要把多个全局变量都整理在一个名称空间下，你将显著降低与其他应用程序、组件或类库之间产生糟糕的相互影响的可能性。</li>
  <li>你的程序也会变得更容易阅读。</li>
  </ul>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>Placeholders in Form Field Are Harmful</title>
      <link>http://www.useLessblog.cn/article/placeholder.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/placeholder.html</guid>
      <pubDate>Fri, 07 Mar 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <!-- $$solo_more$$ -->

<blockquote>
  <p><strong>总结：</strong> placeholder文本在一个表单内很难让用户去记得表单里面的信息，也很难去检查和修复错误，同时，也会给用户增加视觉和认知障碍方面的额外负担。 </p>
</blockquote>

<p>在上下文中说明或提示有助于解释清楚每个表单域的作用，从而提高完成率和<a href="">转化率</a>。表单有很多种提示的的方法，常见的一种方法就是在表单中插入一个说明。不幸的是，经过用户不断的测试表明，<strong>Placeholders这种方法损坏了表单的可用性，而不是起到了帮助的作用。</strong></p>

<h3>标签（labels）和占位符（placeholder）</h3>

<p>标签（Labels）是告知用户一个给定的表单域属于什么样的信息，经常被放在表单域的外面。占位符(Placeholder)文本位于表单域的内部，是一个额外的提示，说明，或是特殊域所要求信息的例子。当用户操作这个表单域的时候，这些提示通常会消失。</p>

<p><img src="/images/label-placeholder-captions.png" alt="Placeholders" title="" />;</p>

<h3>占位符（Placeholders）替换标签（Labels）</h3>

<p>用表单域里面的占位符文本来替换表单域的标签这些形式可以减少页面上的混乱，或是缩短表单的长度。虽然这种方法是个好的意向，但是我们研究表明，placeholders有很多的负面后果。</p>

<p><img src="/images/placeholder-as-label.png" alt="Placeholders" title="" />;</p>

<p>Worst:这个例子，占位符文本被用来代替标签。</p>

<h3>以下是解释为什么占位符(Placeholders)不应该被用来代替标签域（filed labels）。</h3>

<blockquote>
  <p>1、<strong>消失的占位符文本（Placeholder text）会破坏用户的<a href="http://www.nngroup.com/articles/short-term-memory-and-web-usability/">短期记忆</a></strong></p>
</blockquote>

<p>当用户快要填完很长表单的时候，忘记了表单中的提示，这时候，他不得不去删除他写在表单上面的信息，然后再点击表单域的外面，占位符文本才会再显示。在理想的情况下，用户即将要填完表单的时候才会完全集中。但实际上，用户有很多任务。他们有不同的标签打开，或者他们被一个email或是电话拉走。对于这些复杂的任务，他们或许不得不停下来去检索文档或者订单号。从我们的<a href="http://www.nngroup.com/reports/mobile-website-and-application-usability/">移动可用性研究</a>中我们知道，移动用户也经常会分心，然后不小心就中断他们使用的设备。所以，帮助用户拿起他们拉下的地方很重要。</p>

<p>对于简单的表单来说，频繁的使用一两个表单，例如搜索表单或登录表单。比使用复杂或少用的表单少破坏用户的记忆点。因为用简单，相似的表单，用户可以猜到它们应该输入什么。</p>

<p>参考：</p>

<blockquote>
  <ul>
  <li><a href="https://github.com/TooBug/TooSolo">https://github.com/TooBug/TooSolo</a></li>
  <li><a href="https://github.com/TooBug/TooSolo/issues/17">https://github.com/TooBug/TooSolo/issues/17</a></li>
  <li><a href="https://github.com/TooBug/TooSolo/issues/21">https://github.com/TooBug/TooSolo/issues/21</a></li>
  </ul>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>如何用toosolo建静态博客</title>
      <link>http://www.useLessblog.cn/article/toosolo.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/toosolo.html</guid>
      <pubDate>Fri, 07 Mar 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>在创建博客之前，你是不是忘了一件事呢？是的，你需要一个域名。你是不是现在立刻去万网之类的网站购买域名？先不要着急，这里提供两种方法给你选择，一种是你可以买了域名之后绑定到github page上面，就不需要去备案啥的。另一种是直接用github page上面的域名，例如：username.github.io。是不是不知道怎么操作，没事，你可以看 <a href="http://littledu.net/article/how-to-use-github.html">这里</a>。另外，建议你在买域名之前先看<a href="http://www.zhihu.com/question/20556410">这篇文章</a>。</p>

<p>言归正传，首先你先到<a href="https://github.com/TooBug/TooSolo">这里</a>了解Toosolo。是的，他里面也有教程，但是我还是要写这篇文章，至于问为什么，我也不知道。我只知道我写的唯一优势就是配了图说明。废话不多说，马上开始学习：</p>

<p>第一步：到<a href="http://nodejs.org/">node官网</a>下载node,然后安装。你是不是想问，为什么要安装node,很明显，你没有认真看github里面的内容。答案就是：<strong>Toosolo 是一个由Node构建的静态博客</strong>(PS：这一步就不配图详说了，有人跟我说，会装QQ的人都会装node。T^T)</p>

<p>第二步：安装Toosolo。</p>

<blockquote>
  <ul>
  <li><strong>windows + R</strong>输入<strong>cmd</strong>打开控制台;</li>
  <li>输入<strong>npm install -g toosolo</strong>执行命令。</li>
  <li>如果出现下图，恭喜你，说明你安装成功了！</li>
  </ul>
</blockquote>

<p><img src="/images/solo1.jpg" alt="Toosolo" title="" /></p>

<p>第三步：初始化Toosolo。</p>

<blockquote>
  <ul>
  <li>在你喜欢的磁盘中建个空文件夹;</li>
  <li>输入<strong>toosolo --init</strong> 或<strong> toosolo -i</strong>;</li>
  <li>如果你建的文件夹中有个source文件夹和config.json的文件，那么，恭喜你，初始化成功！</li>
  </ul>
</blockquote>

<p><img src="/images/solo2.jpg" alt="Toosolo" title="" /></p>

<p>初始化之后，里面文件夹及文件说明如下图：</p>

<p><img src="/images/solo3.jpg" alt="Toosolo" title="" /></p>

<p>第四步：编译toosolo。</p>

<blockquote>
  <ul>
  <li>在你每次修改toosolo里面的任何文件之后;</li>
  <li>定位到config.json所在的目录，然后执行toosolo这个命令;</li>
  <li>然后你会在你建的文件夹中看到一个dist文件夹</li>
  </ul>
</blockquote>

<p>额外知识：</p>

<pre><code>    D:  -&gt; 进入盘符
    dir  -&gt; 查看目录
    cd xxx -&gt; 进入 xxx 目录
    cd ../ -&gt; 回退到上层目录
</code></pre>

<p><img src="/images/solo4.jpg" alt="Toosolo" title="" /></p>

<p>第五步：然后在dist文件夹中打开index.html，就可以看到toosolo的模板了！</p>

<p>哈哈，执行到这里，就不用步骤形容了。</p>

<h3>接下来的问题是：如何将toosolo放到你的域名中展示呢？</h3>

<p>很简单，你只需将dist文件夹里面的文件复制你的空间中就行，然后修改config.json中的distPath。如图：</p>

<p><img src="/images/solo5.jpg" alt="Toosolo" title="" /></p>

<p>如果你是用github page的域名或是将你自己的域名绑定到github page，你可以按<a href="http://littledu.net/article/how-to-use-github.html">这里</a>的步骤去做。</p>

<p>注意，如果是将绑定自己的域名到github page，记得修改source/global/CNAME为自己的域名，不然每次commit的时候都会变回原来的。如图：</p>

<p><img src="/images/solo6.jpg" alt="Toosolo" title="" /></p>

<h3>看到这里，你是不是还有个疑问，如果我想改里面的排版或是样式要在哪里改？</h3>

<blockquote>
  <ul>
  <li>执行这个命令：<strong>toosolo --skin</strong>或是<strong>toosolo -s</strong>;</li>
  <li>你会在./source目录下看到有个skin的文件夹。</li>
  </ul>
</blockquote>

<p>如图：</p>

<p><img src="/images/solo7.jpg" alt="Toosolo" title="" /></p>

<p>skin里面文件夹介绍如图：</p>

<p><img src="/images/solo8.jpg" alt="Toosolo" title="" /></p>

<p>提醒：里面涉及到了使用jade。当然，要想发博客，你要先知道markdown（哈哈，这句貌似应该是在最前面提的，不管了）。你可以通过以下的链接进行了解：</p>

<blockquote>
  <ul>
  <li><p>了解markdown链接如下：
  <a href="https://www.zybuluo.com/mdeditor">https://www.zybuluo.com/mdeditor</a>
  <a href="http://wowubuntu.com/markdown/">http://wowubuntu.com/markdown/</a></p></li>
  <li><p>了解jade链接如下：
  <a href="http://naltatis.github.io/jade-syntax-docs/">http://naltatis.github.io/jade-syntax-docs/</a></p></li>
  </ul>
</blockquote>

<h3>还有一个问题，我要在哪里写我要发表的文章呢？</h3>

<p>看图说话：</p>

<p><img src="/images/solo9.jpg" alt="Toosolo" title="" /></p>

<h3>最后一个问题，页面上的图片要放在哪呢？图片怎么在本地看不到呢？</h3>

<blockquote>
  <ul>
  <li>页面上的图片放在/source/global/images目录下</li>
  <li>图片要推到外网之后才能看到，这个不用担心。</li>
  </ul>
</blockquote>

<p>哈哈，还有什么问题，可以在评论中提出来的哈。。。。。。</p>

<p>参考：</p>

<blockquote>
  <ul>
  <li><a href="https://github.com/TooBug/TooSolo">https://github.com/TooBug/TooSolo</a></li>
  <li><a href="https://github.com/TooBug/TooSolo/issues/17">https://github.com/TooBug/TooSolo/issues/17</a></li>
  <li><a href="https://github.com/TooBug/TooSolo/issues/21">https://github.com/TooBug/TooSolo/issues/21</a></li>
  </ul>
</blockquote>
        ]]>
      </description>
    </item>
  </channel>
</rss>