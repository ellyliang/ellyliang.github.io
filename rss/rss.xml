<?xml version="1.0" encoding="utf-8" ?>
<rss version="2.0">
  <channel>
    <title>useLess[blog]</title>
    <link>http://www.useLessblog.cn</link>
    <description>useLess - 前端开发</description>
    <lastBuildDate>Tue, 09 Sep 2014 00:00:00 +0800</lastBuildDate>
    <generator>Solo 2.0</generator>
    <item>
      <title>译文：确保不在javascript中增加全局作用域</title>
      <link>http://www.useLessblog.cn/article/not-adding-global-scope.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/not-adding-global-scope.html</guid>
      <pubDate>Tue, 09 Sep 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>写javascript代码最好的做法是避免把对象放到全局作用域中。有几个很好的理由来解释全局变量会增加耦合（globals add coupling），例如，分开不同库的时候，很容易破坏彼此。事实上，通常程序的规则是避免增加全局作用域。遗憾的是，javascript增加对象到全局作用域中是非常容易的事情。参考以下这段代码：</p>

<pre><code>function sayHello(person)
{
    message = "Hello, " + person;
    $("#message").text(message);
}

sayHello('@ardalis');


&lt;div id="message" /&gt;
</code></pre>

<p>在这个例子中，我们定义了一个函数，在函数里边设置了一个变量，然后用jquery去修改div。但是因为我们没有声明<code>var</code>这个关键词，所以实际上我们已经增加了一个新的对象message到全局作用域中。事实上，如果其他的一些函数也存在message这个全局对象，那么我们刚声明的message就会覆盖掉其他一些函数的message，从而可能导致系统的其他部分被破坏，即使其他部分没有被修改过。增加紧密的耦合（tight coupling）在我们的设计中，很可能不经意间，会使我们写的javascript应用更加脆弱且更难维护。</p>

<p>另外，全局作用域很容易意外的导致错误，那么我们如何去避免它？当然有一些工具对找出javascript中的错误问题很有帮助,例如JSLint 。运行<code>sayHello()</code>函数，通过JSLint可以让你知道<code>message</code>在使用之前有没有被定义过。</p>

<h3>全局数量</h3>

<p>另一种方法是在全局空间中计算对象的数量，确保你没有增加同一个全局对象。这样做可以作为你测试套件每个函数的基础，声明每个函数开始和结束都没有改变全局状态的一部分（或是，如果函数想要增加到全局状态中，确保该函数中的对象是唯一你想要的）。关键是在给定的时间里能够计算多少个全局对象。你可以执行以下的代码：</p>

<pre><code>function sayHello(person)
{
    message = "Hello, " + person;
    $("#message").text(message);
}

function sayHelloShouldNotAddToGlobalScope(globalObject)
{
    var initialGlobalCount = Object.keys(globalObject).length;
    sayHello("@ardalis");
    var endGlobalCount = Object.keys(globalObject).length;
    if(initialGlobalCount == endGlobalCount) {
        $("#result").text("Success!");
    } else {
        $("#result").text("Failed - Initial Count: " + 
                            initialGlobalCount + 
                            " End Count: " +
                            endGlobalCount);
    }
}

$(document).ready(function() {
    // run test
    sayHelloShouldNotAddToGlobalScope(window);    
});



&lt;p id="message" /&gt;
&lt;p id="result" /&gt;
</code></pre>

<p>运行这个函数，你应该可以看到，该函数在全局作用域的结束比开始多了个项目（确切的数字会在不同的环境中运行该函数）。</p>

<h3>使用严格模式</h3>

<p>另一个方法是声明<code>"use strict;"</code>模式。它的做法很简单，无论是本地或是全局，在你的代码中增加<code>"use strict"</code>这个字符串，然后末尾加个分号。像这样：</p>

<pre><code>"use strict";
</code></pre>

<p>这样做除了其他事项外，还可以防止使用未声明的变量，未声明的变量是上面所以提及的sayHello()函数问题的根源。Chrome 13+, IE 10+, Safari 5.1+, 和Firefox 4+都兼容严格模式。如果你添加严格模式到上面的代码中（请看<a href="http://jsfiddle.net/7Rx32/4/">fiddle</a>）,当你运行代码的时候，你会发现有个错误（请查阅开发者工具的console）:</p>

<p><img src="/images/image_3.png" alt="说明" title="" /></p>

<h3>总结</h3>

<p>大多数现代浏览器都支持"use strict"，同时使用严格模式可以养成良好的代码习惯，而且严格模式会阻止常见的问题，例如不经意将对象添加到全局作用域中。你也可以在全局对象之前和执行方法之后检查对象的数量，最好做法是在你的javascript单元测试中检查对象的数量。</p>

<h3>原文链接：</h3>

<blockquote>
  <ul>
  <li><a href="http://ardalis.com/ensure-you-are-not-adding-to-global-scope-in-javascript?utm_source=feweekly&amp;utm_campaign=issue39&amp;utm_medium=web">hhttp://ardalis.com/ensure-you-are-not-adding-to-global-scope-in-javascript?utm<em>source=feweekly&amp;utm</em>campaign=issue39&amp;utm_medium=web</a></li>
  </ul>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>译文《CSS:响应式导航菜单》</title>
      <link>http://www.useLessblog.cn/article/css-responsive-navigation-menu.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/css-responsive-navigation-menu.html</guid>
      <pubDate>Tue, 12 Aug 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>之前我（原文作者）已经写过一篇关于如何制作响应式设计<a href="http://webdesignerwall.com/tutorials/mobile-navigation-design-tutorial">手机导航 </a>的教程，但现在我（原文作者）发现一个不需要使用javascript也可以制作响应式菜单的方法。它使用了简洁和语义化的html5标签，菜单可以向左，中间或右对齐。前面的教程菜单只能点击切换，本教程的菜单是通过hover切换，这样用户体验更友好。另外，用active/current来提示选中的菜单项，还可以在所有移动端浏览器和包括ie在内的桌面浏览器中运行。</p>

<p><a href="http://webdesignerwall.com/demo/responsive-menu/">css响应式菜单demo</a></p>

<h3>目的</h3>

<p>本教程的目的是告诉你如何把一个普通列表菜单变成下拉菜单显示在更小的屏幕上。</p>

<p><img src="/images/css.png" alt="图片" title="" /></p>

<p>这种做法对带有许多链接的导航更有用些，如下图。你可以将所有的按钮集成一个优雅的下拉菜单。</p>

<p><img src="/images/css1.png" alt="图片" title="" /></p>

<h3>导航的html标签</h3>

<p>这个是导航的标签。<code>&lt;nav&gt;</code>这个标签是创建下拉菜单的，同时需要给这个标签绝对定位的属性。我将在教程的最后说明这个标签。<code>.current</code>这个class是指选中的菜单选项。</p>

<pre><code>&lt;nav class="nav"&gt;
    &lt;ul&gt;
        &lt;li class="current"&gt;&lt;a href="#"&gt;Portfolio&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="#"&gt;Illustration&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="#"&gt;Web Design&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="#"&gt;Print Media&lt;/a&gt;&lt;/li&gt;
        &lt;li&gt;&lt;a href="#"&gt;Graphic Design&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
&lt;/nav&gt;
</code></pre>

<h3>CSS</h3>

<p>导航的css实现（PC端）非常简单，所以我（原文作者）不打算进入细节。注意，我（原文作者）将<code>nav</code>中的<code>&lt;li&gt;</code>元素的浮动<code>float:left</code>用<code>display:inline-block</code>代替。因为这样做允许菜单的按钮能够向左，中间或右对齐，通过设置<code>&lt;ul&gt;</code>标签的<code>text-align</code>的属性。</p>

<pre><code>/* nav */
.nav {
    position: relative;
    margin: 20px 0;
}
.nav ul {
    margin: 0;
    padding: 0;
}
.nav li {
    margin: 0 5px 10px 0;
    padding: 0;
    list-style: none;
    display: inline-block;
}
.nav a {
    padding: 3px 12px;
    text-decoration: none;
    color: #999;
    line-height: 100%;
}
.nav a:hover {
    color: #000;
}
.nav .current a {
    background: #999;
    color: #fff;
    border-radius: 5px;
}
</code></pre>

<h3>向中间和右对齐</h3>

<p>如上所述，你可以使用<code>text-align</code>属性来改变按钮的对齐方式。</p>

<pre><code>/* right nav */
.nav.right ul {
    text-align: right;
}

/* center nav */
.nav.center ul {
    text-align: center;
}
</code></pre>

<h3>支持Internet Explorer</h3>

<p>HTML5  <code>&lt;nav&gt;</code>和媒体查询对IE8及以下版本浏览器不支持。因此需要引入<a href="https://code.google.com/p/css3-mediaqueries-js/">css3-mediaqueries.js</a>（或<a href="https://github.com/scottjehl/Respond">respond.js</a>）和<a href="https://code.google.com/p/html5shim/">html5shim.js</a>。如果你不想引入html5shim.js，可以用<code>div</code>标签代替<code>nav</code>标签。</p>

<pre><code>&lt;!--[if lt IE 9]&gt;
    &lt;script src="http://css3-mediaqueries-js.googlecode.com/files/css3-mediaqueries.js"&gt;&lt;/script&gt;
    &lt;script src="http://html5shim.googlecode.com/svn/trunk/html5.js"&gt;&lt;/script&gt;
&lt;![endif]--&gt;
</code></pre>

<h3>响应式（Responsive）</h3>

<p>终于来到本教程最有趣的部分-用媒体查询制作响应式菜单！如果你对响应式设计还不熟悉，可以看我（原文作者）之前写关于<a href="http://webdesignerwall.com/tutorials/responsive-design-in-3-steps">responsive design</a>和<a href="http://webdesignerwall.com/tutorials/css3-media-queries">media query</a>的文章。</p>

<p>大约600px临界点的时候，设置nav元素为相对定位（position:relative），<code>&lt;ul&gt;</code>元素设置为绝对定位（<code>position:absolute</code>），将<code>&lt;ul&gt;</code>菜单列表放置顶部(top)。然后将所有<code>&lt;li&gt;</code>元素设置为<code>display:none</code>隐藏掉，但通过<code>.current</code>的属性设置为<code>display:block</code>来让<code>&lt;li&gt;</code>显示。然后鼠标放上或离开（hover）<code>nav</code>标签的时候，设置所有<code>&lt;li&gt;</code>为<code>display:block</code>（这是产生下拉菜单的结果）。我在<code>.current</code>元素上增加一个确认的图形icon去指示选中项。为了菜单能够向中间和右对齐，使用<code>left</code>和<code>right</code>属性去定位<code>&lt;ul&gt;</code>列表。</p>

<blockquote>
  <p><a href="http://webdesignerwall.com/demo/responsive-menu/">demo展示</a></p>
</blockquote>

<pre><code>@media screen and (max-width: 600px) {
    .nav {
        position: relative;
        min-height: 40px;
    }   
    .nav ul {
        width: 180px;
        padding: 5px 0;
        position: absolute;
        top: 0;
        left: 0;
        border: solid 1px #aaa;
        background: #fff url(images/icon-menu.png) no-repeat 10px 11px;
        border-radius: 5px;
        box-shadow: 0 1px 2px rgba(0,0,0,.3);
    }
    .nav li {
        display: none; /* 隐藏所有&lt;li&gt;项 */
        margin: 0;
    }
    .nav .current {
        display: block; /* 只显示当前选中&lt;li&gt;项 */
    }
    .nav a {
        display: block;
        padding: 5px 5px 5px 32px;
        text-align: left;
    }
    .nav .current a {
        background: none;
        color: #666;
    }

    /* 鼠标移到导航上 */
    .nav ul:hover {
        background-image: none;
    }
    .nav ul:hover li {
        display: block;
        margin: 0 0 5px;
    }
    .nav ul:hover .current {
        background: url(images/icon-check.png) no-repeat 10px 7px;
    }

    /* right nav */
    .nav.right ul {
        left: auto;
        right: 0;
    }

    /* center nav */
    .nav.center ul {
        left: 50%;
        margin-left: -90px;
    }

}
</code></pre>

<blockquote>
  <p>本文译自：<a href="http://webdesignerwall.com/tutorials/css-responsive-navigation-menu">http://webdesignerwall.com/tutorials/css-responsive-navigation-menu</a></p>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>Javascript笔记之单例模式</title>
      <link>http://www.useLessblog.cn/article/singletonpattern.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/singletonpattern.html</guid>
      <pubDate>Fri, 11 Jul 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <h3>什么是单例模式？</h3>

<p>利用私有构造函数来保证只有一个实例，使不同的地方调用同一个实例对象。</p>

<h3>单例模式最简单的例子：</h3>

<pre><code>var Useless = {
     name: "useless",
     age: function() {
       console.log("secret!");
     }
};
Useless.age();
</code></pre>

<h3>闭包实现私有成员的单例模式例子：</h3>

<pre><code>var Ellyliang = (function() {
    var name = "useLess",
        age  = function() {
            console.log("secret!");
        };

    return {
        getName: function() {
            return name;
        },
        getAge: function() {
            age();
        }
    }
})();
Ellyliang.getName();
Ellyliang.getAge();
</code></pre>

<h3>闭包实现私有成员的惰性实例化单例模式:</h3>

<pre><code>var Ellyliang = (function() {
    var name = "useLess",
        age = function() {
            console.log("secret!");
        };

    var obj = {
        getName: function(){
            return name;
        },
        getAge: function(){
            age();
        }
    };

    function init(){
        return obj;
    }

    return {
        getInstace: init
    };
})();

Ellyliang.getInstace().getAge();
Ellyliang.getInstace().getAge();
</code></pre>

<p>NOTE: 适用场景－> 必须加载大量数据的单体知道需要使用它的时候才实例化。</p>

<h3>笔记链接：</h3>

<blockquote>
  <ul>
  <li><a href="http://www.cnblogs.com/snandy/archive/2011/04/07/2007717.html">http://www.cnblogs.com/snandy/archive/2011/04/07/2007717.html</a></li>
  <li><a href="http://rolfzhang.com/articles/920.html">http://rolfzhang.com/articles/920.html</a></li>
  </ul>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>css3-萌蜗牛</title>
      <link>http://www.useLessblog.cn/article/snail.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/snail.html</guid>
      <pubDate>Thu, 12 Jun 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>嗯，这个“很萌的蜗牛”由来是因为腾讯一位女程序媛的“一个红点的故事”而且产生的。想看她一个元素做出来的叮当？请看最后的链接！不过，确切来说，自己想通过这只不太像蜗牛的蜗牛学习下css3，哈哈哈哈....</p>

<p><img src="/images/snail.png" alt="Snail" title="" />;</p>

<h3><a href="http://www.uselessblog.cn/JQM-me/snail.html">http://www.uselessblog.cn/JQM-me/snail.html</a></h3>

<p>链接：</p>

<blockquote>
  <ul>
  <li><a href="http://pigrun.github.io/1st_run/demos/pping/pokonyan/pokonyan.html">一个小红点的故事</a></li>
  </ul>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>Javascript作用域&amp;提升-笔记</title>
      <link>http://www.useLessblog.cn/article/scoping&amp;hoisting.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/scoping&amp;hoisting.html</guid>
      <pubDate>Sat, 26 Apr 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>为什么第一个会报错，而第二个没报错，你造吗？不造？好的，接下来我们就一起学习以下的笔记，学完之后你就造了！哈哈......</p>

<pre><code>useLess();  //TypeError: undefined is not a function
var useLess = function(){
    alert(2);
};

useLess(); //2
function useLess(){
    alert(2);
}
</code></pre>

<h3>Note1--Javascript拥有2种作用域：全局作用域和函数作用域。在Javascript中的块（例如：if-else）不会创建新的作用域，函数才会创建新的作用域。</h3>

<p>栗子：</p>

<pre><code>var name = "useLess";
console.log(name); //"useLess"
if(true){
    console.log(name); //"useLess"
    var name = "ellyLiang"; 
    console.log(name); //"ellyLiang"
}
console.log(name); //"ellyLiang"
</code></pre>

<h3>Note2--如果想在Javascript中创建一个临时作用域，可用即时函数。</h3>

<p>栗子：</p>

<pre><code>var name = "useLess";
if(true){
    (function(){
        var name="ellyLiang";
        console.log(name); //"ellyLiang"
    }());
    console.log(name); //"useLess"
}
console.log(name); //"useLess"
</code></pre>

<h3>Note3--使用var声明的变量名会提升到作用域的顶端，函数声明也会提升。</h3>

<p>栗子：</p>

<pre><code>function blog(){
    func();
    var name = "www.useLessblog.cn";
}
</code></pre>

<p>被解释为：</p>

<pre><code>function blog(){
    var name;
    func();
    name = "www.useLessblog.cn";
}
</code></pre>

<h3>Note4--有一种情况，声明所在的语句不执行，但是不影响提升的机制。</h3>

<p>栗子：</p>

<pre><code>function blog(){
    if(false){
        var name = "www.useLessblog.cn";
    }
    return;   //中断
    var github = "ellyLiang";  //不执行
}
</code></pre>

<p>与上面blog函数等效：</p>

<pre><code>function blog(){
    var name, github;
    if(false){
        name = "www.useLessblog.cn";
    }
    return; //中断
    github = "ellyLiang"; //不执行
}
</code></pre>

<h3>Note5--声明和赋值一起写，但是赋值不会被提升，只有变量名被提升到函数顶部。函数声明，整个函数名和函数体都会被提升。</h3>

<p>栗子：</p>

<pre><code>function me(){
    blog();  //Uncaught TypeError: undefined is not a function 
    useLess();  //"Yes, useLess is a Woman man!" 

    var blog = function(){  //函数表达式（PS：blog普通变量，然后把函数赋值给blog，因此blog这个变量名被提升，而函数部分未被提升。）
        console.log("www.useLessblog.cn");
    };

    function useLess(){    //完整的函数声明
        console.log("Yes, useLess is a Woman man!");
    }
}
me();
</code></pre>

<p>注：useLess函数声明的函数体被提升了；blog变量名被提升，但是函数部分未被提升！</p>

<h3>Note6--变量识别顺序</h3>

<p>如果一个变量已经被定义了，它就不会被另一个相同名字的变量覆盖，这意味着函数声明比函数变量声明有更高的优先级。但是不影响对这个变量赋值的继续运行，只是声明会被忽略。</p>

<p>栗子：</p>

<pre><code>function useLess(){}
var useLess = "Yes,useLess is a Woman man!";
console.log(useLess); //"Yes,useLess is a Woman man!"
</code></pre>

<p>被解释为：</p>

<pre><code>function useLess(){}
//var useLess; //会被忽略掉
useLess = "Yes,useLess is a Woman man!";
console.log(useLess); //"Yes,useLess is a Woman man!"
</code></pre>

<h3>Note7--带有名字的函数表达式->可以给函数表达式起个名字，采用函数声明的语法，但不能使它成为一个函数声明，函数体也不会被提升。</h3>

<p>栗子：</p>

<pre><code>blog(); //Uncaught TypeError: Property 'blog' of object [object Object] is not a function 
useLess(); //Uncaught ReferenceError: useLess is not defined 

var blog = function useLess(){};
</code></pre>

<h3>最后总结：</h3>

<p>总是使用var声明变量，强烈建议在每个作用域顶部写一个var语句，这么做，就不会遇到提升相关的困惑了！
哈哈~看完明白上面那2个函数的区别了么，还是不明白？好吧，建议去翻译笔主的博客学习！链接在下面！灰常
感谢<a href="http://www.basecss.net">@basecss</a>提供的信息和指导！这篇笔记如有错误的地方，欢迎大家指正，同时，我会继续学习作用域，然后再修改这篇笔记，希望大家多指导！大家有兴趣交流JS，可以加入JS交流群：365143137！</p>

<p>参考：</p>

<blockquote>
  <ul>
  <li><a href="http://octsky.com/post/65/">http://octsky.com/post/65/</a></li>
  </ul>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>Grunt安装过程</title>
      <link>http://www.useLessblog.cn/article/install-grunt.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/install-grunt.html</guid>
      <pubDate>Fri, 28 Mar 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>Grunt是啥么？可以到<a href="http://www.gruntjs.org/">Grunt中文社区</a>了解。
哈哈，是的，我是一名前端菜鸟，一开始不知道Grunt是什么，也不知道Grunt可以做什么，而且进入到官网看的时候，还是不大明白，但是到你按官网的里面步骤走一遍的时候，你就会初步知道grunt的作用。</p>

<p>当然，你要安装grunt,首先你要安装nodejs。可以到<a href="http://nodejs.org/">node官网</a>下载安装包，跟第一篇博客一样，不讲解node的安装过程。</p>

<p>下面是Grunt安装过程图文讲解：</p>

<h3>第一步：安装全局的Grunt cli。</h3>

<p>执行命令：</p>

<pre><code>npm install -g grunt-cli
</code></pre>

<p>如下图，恭喜你安装成功！</p>

<p><img src="/images/grunt1.jpg" alt="Grunt" title="" />;</p>

<h3>第二步：自动创建package.json。(PS:你也可以手动创建，参考<a href="http://www.gruntjs.org/docs/getting-started.html">Grunt官网的新手上路</a>)</h3>

<p>执行命令：</p>

<pre><code>npm init
</code></pre>

<p>如下图，恭喜创建成功！</p>

<p><img src="/images/grunt2.jpg" alt="Grunt" title="" />;</p>

<h3>第三步：本地安装&lt; module >（PS:安装插件到当前目录 同时生成依赖)</h3>

<p>执行命令：</p>

<pre><code>npm install module --save-dev
</code></pre>

<p>如下图，恭喜安装成功！</p>

<p><img src="/images/grunt3.jpg" alt="Grunt" title="" />;</p>

<h3>第四步：安装Grunt到你的项目中</h3>

<p>执行命令：</p>

<pre><code>npm install grunt --save-dev
</code></pre>

<p>如下图，恭喜安装成功！</p>

<p><img src="/images/grunt4.jpg" alt="Grunt" title="" />;</p>

<p>note: 这步安装的时候，npm可能会抽风（就是停在那里不动），建议安装个cnpm,详细可看<a href="http://cnpmjs.org/">cnpmjs.org</a>,安装完成之后，跟你之前一样运行你的命令。</p>

<p>安装cnpm的命令：</p>

<pre><code>npm install -g -cnpm --register-http://r.cnpmjs.org
</code></pre>

<h3>第五步：配置和插件（Gruntfile.js）(PS:哈哈，我个人感觉，安装过程简单，但是配置过程难)。</h3>

<blockquote>
  <ul>
  <li>在你的项目中建一个gruntfile.js文件。</li>
  <li>gruntfile.js通用写法如下：</li>
  </ul>
</blockquote>

<pre><code>module.exports = function(grunt) {
    grunt.initConfig({
        pkg: grunt.file.readJSON('package.json');
    });
};
</code></pre>

<blockquote>
  <ul>
  <li>添加grunt uglify(压缩)插件，当然还有很多插件，例如grunt LESS、grunt Jshint、grunt concat等等，具体自己google，这里我就简单演示grunt uglify和grunt watch。</li>
  </ul>
</blockquote>

<ul>
<li>首先，你要先下载grunt uglify。</li>
</ul>

<p>执行命令：</p>

<pre><code>npm install grunt-contrib-uglify
</code></pre>

<p>如下图，恭喜下载成功！</p>

<p><img src="/images/grunt5.jpg" alt="Grunt" title="" />;</p>

<p>然后gruntfile.js配置:</p>

<pre><code>module.exports = function(grunt) {
    grunt.initConfig({
        pkg: grunt.file.readJSON('package.json'),

        uglify: {
            default: {
                files: [{
                    expand: true,
                    cwd: 'JS/',     //源目录
                    src: '**/*.js',    //源文件后缀
                    dest: 'minJS/',   //目标目录
                    ext: '.min.js'    //生成文件的后缀
                }]
            }
        }
    });

    //任务加载
    grunt.loadNpmTasks('grunt-contrib-uglify');

    //任务自定义
    grunt.registerTask('default', ['uglify']);
};   
</code></pre>

<p>配置完成后，执行grunt命令,如下图：</p>

<p><img src="/images/grunt6.jpg" alt="Grunt" title="" />;</p>

<pre><code>PS:
    grunt -&gt; 执行默认任务
    grunt taskname -&gt; 执行指定任务
</code></pre>

<p>然后你会看到minJS生成一个了的压缩的useLess.min.js,如图：</p>

<p><img src="/images/grunt7.jpg" alt="Grunt" title="" />;</p>

<p>我的目录结构：</p>

<pre><code>——test
  |__JS
     |__useLess.js
  |__minJS

//当执行完grunt后，minJS中会生成个useLess.min.js。
</code></pre>

<blockquote>
  <ol>
  <li>添加grunt watch(自动化)插件</li>
  </ol>
</blockquote>

<p>运行命令：</p>

<pre><code>npm install grunt-contrib-watch
</code></pre>

<p>这步就不配下载成功的图了。</p>

<p>在gruntfile.js中添加任务：</p>

<pre><code>module.exports = function(grunt) {
    grunt.initConfig({
        pkg: grunt.file.readJSON('package.json'),

        uglify: {
            default: {
                files: [{
                    expand: true,
                    cwd: 'JS/',     //源目录
                    src: '**/*.js',    //源文件后缀
                    dest: 'minJS/',   //目标目录
                    ext: '.min.js'    //生成文件的后缀
                }]
            }
        },
        watch: {
            scripts: {
                files: ['**/*.js'],
                tasks: ['uglify'],
                options: {
                    spawn: false,
                },
            }
        }
    });

    //任务加载
    grunt.loadNpmTasks('grunt-contrib-uglify');
    grunt.loadNpmTasks('grunt-contrib-watch');

    //任务自定义
    grunt.registerTask('default', ['uglify', 'watch']);
};
</code></pre>

<p>grunt watch在你每次修改useLess.js的时候，都会自动帮你压缩，不用每次都要执行grunt命令，如图：</p>

<p>没修改useLess.js之前：</p>

<p><img src="/images/grunt8.jpg" alt="Grunt" title="" />;</p>

<p>修改useLess.js之后，自动压缩useLess.js成useLess.min.js：</p>

<p><img src="/images/grunt9.jpg" alt="Grunt" title="" />;</p>

<p>如果你想安装非全局的grunt，看<a href="http://www.basecss.net/article/using-grunt-in-local.html">这里</a>。</p>

<p>哈哈，你照着上面5个步骤去做，有没有初步了解了grunt是做什么的了呢？不知道！那就继续看<a href="http://www.gruntjs.org/">grunt官网</a>或是google更多关于grunt的知识，或是看我下面的链接。当然，这篇文章有很多不足的地方，求各位大神指点！当然，感谢那些耐心解答我问题的大牛们，有机会的话，请你们吃M记，嘻嘻。。。！</p>

<p>文章就到此结束鸟。。。。</p>

<p>参考：</p>

<blockquote>
  <ul>
  <li><a href="http://www.gruntjs.org/">http://www.gruntjs.org/</a></li>
  <li><a href="http://docs.spmjs.org/contrib/simple-grunt">http://docs.spmjs.org/contrib/simple-grunt</a></li>
  <li><a href="https://github.com/TVVT/mobile-start">https://github.com/TVVT/mobile-start</a></li>
  <li><a href="http://www.w3cplus.com/tools/grunt-tutorial-installing-grunt.html">http://www.w3cplus.com/tools/grunt-tutorial-installing-grunt.html</a></li>
  <li><a href="http://www.w3cplus.com/tools/automating-your-workflow-with-grunt.html">http://www.w3cplus.com/tools/automating-your-workflow-with-grunt.html</a></li>
  </ul>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>《JS语言精粹》笔记之函数第一部分</title>
      <link>http://www.useLessblog.cn/article/func.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/func.html</guid>
      <pubDate>Sat, 22 Mar 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <ul>
<li>函数包含一组语句，它们是JS的基础模块单元，用于代码复用、信息隐藏和组合调用。</li>
<li>函数用于指定对象的行为。</li>
<li>所谓编程，就是将一组需求分解成一组函数和数据结构的技能。</li>
</ul>

<h3>函数对象</h3>

<blockquote>
  <ul>
  <li>函数就是对象。</li>
  <li>对象字面量产生的对象连接到Object.prototype。</li>
  <li>函数对象连接到Function.prototype(其本身连接到Object.prototype)。</li>
  <li><p>函数在创建时附有两个附加的隐藏属性：函数的上下文和实现函数行为的代码。</p></li>
  <li><p>函数可以保存在变量、对象和数组中。</p></li>
  <li>函数可以被当做参数传递给其他函数，函数也可以返回函数。</li>
  <li>函数是对象，所以函数拥有方法。函数的不同之处是，函数可以被调用。</li>
  </ul>
</blockquote>

<h3>函数字面量</h3>

<blockquote>
  <ul>
  <li>函数包含4个部分：
  *1. 保留字function；
  *2. 函数名，可省略；
  *3. 包围在花括号的一组参数；
  *4. 包围在花括号的一组语句（函数的主体，被调用时执行）。</li>
  <li>一个内部函数除了可以访问自己的参数和变量，也能自由访问把它嵌套在其中的父函数的参数与变量。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var add = function(a, b) {
    return a + b;
};
</code></pre>

<h3>调用</h3>

<blockquote>
  <ul>
  <li>调用一个函数会暂停当前函数的执行，传递控制权和参数给新函数。</li>
  <li>除了声明时定义的形式参数，每个函数还接收2个附加的参数：this和arguments（this取决于调用的模式）。</li>
  <li>JS中有4种调用模式：方法调用模式、函数调用模式、构造器调用函数和apply调用模式。</li>
  <li>当实际参数（arguments）的个数与形式参数（parameters）的个数不匹配时，不会导致运行时错误。</li>
  <li>参数值过多时，超出的参数值会被忽略。如果实际参数值过少，缺失的值会被替换为undefined。</li>
  </ul>
</blockquote>

<h3>方法调用</h3>

<p>一个函数被保存为对象的一个属性时，称它为一个方法。</p>

<blockquote>
  <ul>
  <li>一个方法被调用时，this被绑定到该对象。</li>
  <li>方法可以使用this访问自己所属的对象，所以它能从对象中取值或对对象进行修改。</li>
  <li>通过this可取得它们所属对象的上下文的方法称为公共方法。</li>
  </ul>
</blockquote>

<p>例如： 
    var myObject = {
        value: 0,</p>

<pre><code>    increment: function(inc) {   //公共方法
        this.value += typeof inc === 'number' ? inc : 1;
    }
};

myObject.increment();
document.writeln(myObject.value); //1

myObject.increment(2);
document.writeln(myObject.value); //3
</code></pre>

<h3>函数调用模式</h3>

<p>函数调用模式的this被绑定带全局对象，让this变成局部变量的解决办法是var that = this。</p>

<p>例如：
    myObject.double = function() {
        var that = this;  //解决方法</p>

<pre><code>    var helper = function() {
        that.value = add(that.value, that.value);
    };

    helper();
};

//调用
myObject.double();
console.log(myObject.value); //6
</code></pre>

<h3>构造器调用模式</h3>

<p>函数前面带上new调用，那么背地里将会创建一个链接到该函数的prototype成员的新对象,同时this会绑定到这个新对象上。</p>

<pre><code>//创建一个构造函数，带有一个status属性的对象
var Quo = function(string) {
    this.status = string;
};
//增加一个get_status公共方法
Quo.prototype.get_status = function() {
    return this.status;
};
//构造Quo实例
var myQuo = new Quo('confused');
cosole.log(myQuo.get_status()); //"confused"
</code></pre>

<h3>Apply调用模式</h3>

<blockquote>
  <ul>
  <li>apply方法构建一个参数数组传递给调用函数，允许我们选择this值。</li>
  <li>apply方法接收2个参数，1：绑定给this的值，2：参数数组（arguments）。</li>
  </ul>
</blockquote>

<pre><code>//Apply调用模式：构建一个参数数组传递给调用函数。
//构造一个数组，并让它们相加
var array = [3, 4];
var sum = add.apply(null,array); //7

//apply调用模式
//构造一个包含status成员的对象
var statusObject = {
    status: 'A-OK'
};

var status = Quo.prototype.get_status.apply(statusObject); //'A-OK'
</code></pre>

<p>哈哈，笔记待续中。。。。。</p>
        ]]>
      </description>
    </item>
    <item>
      <title>《JS语言精粹》笔记之对象</title>
      <link>http://www.useLessblog.cn/article/object.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/object.html</guid>
      <pubDate>Sat, 15 Mar 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <ul>
<li>JS简单类型：数字、字符串、布尔值（true 和 false）、null值和undefined值。</li>
<li>其他所有值都是对象。</li>
<li>数组是对象，函数是对象，正则表达式是对象，当然，对象也是对象。</li>
<li>Prototype(原型链)：允许对象继承另一个对象的属性。正确的使用它，能减少对象初始化时消耗的时间和内存。</li>
</ul>

<h3>对象字面量</h3>

<blockquote>
  <ul>
  <li>对象字面量提供了一种非常方便的创建新对象值得表示法。</li>
  <li>对象字面量就是包围在一对花括号中的零或多个“名/值” 对。</li>
  <li>对象字面量出现在任何允许表达式出现的地方</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var empty_obj = {};

var stooge = {
    'first_name' : 'cm',
    'last_name' : 'liang'
};
</code></pre>

<blockquote>
  <ul>
  <li>属性名可以是包括空字符串在内的任何字符串；</li>
  <li>在字面量中，如果属性名是一个合法的JS标识且不是保留字，则并不强求用引号括住属性名；</li>
  <li>逗号是用来分隔多个“名/值”对；</li>
  <li>属性值可以从包括另一个对象字面量在内的任意表达式中获得。</li>
  </ul>
</blockquote>

<pre><code>var flight = {
    airline: 'Oceanic',
    number: 815,
    departure: {
        IATA: 'SYD',
        time: '2014-01-01',
        city: 'GZ'
    },
    arrival: {
        IATA: 'LAX',
        time: '2013-01-01',
        city: 'SZ'
    }
};
</code></pre>

<h3>检索</h3>

<blockquote>
  <ul>
  <li>检索对象中包含的值，有两种方式：
  <ul><li>1.在[]后缀中括住一个字符串表达式的方式。</li>
  <li>2.<strong>优先考虑的方法</strong>，使用 . 表示法，它更紧凑且可读性更好。</li></ul></li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>stooge['first_name']; //cm
flight.arrival.city; //SZ
</code></pre>

<blockquote>
  <ul>
  <li>检索一个不存在的成员元素的值，返回“undefined”。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>stooge['middle_name']; //undefined
flight.goWhere; //undefined
</code></pre>

<blockquote>
  <ul>
  <li>||用来填充默认值</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var middle = stooge['middle_name'] || '(none)';
middle; //"(none)"

var status = flight.status || 'unknown';
status;   //unknown
</code></pre>

<blockquote>
  <ul>
  <li>检索一个undefined值会导致TypeError异常。可以通过&amp;&amp;运算符来避免错误。</li>
  </ul>
</blockquote>

<pre><code>stooge.address; //undefined
stooge.address.language; //throw "TypeError"
stooge.address &amp;&amp; stooge.address.language; //undefined
</code></pre>

<h3>更新</h3>

<blockquote>
  <ul>
  <li>对象中的值可以通过赋值语句来更新。</li>
  <li>如果属性名已经存在对象中，那个这个属性值会被替换。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>stooge.first_name = "elly";
stooge.first_name; //"elly"
</code></pre>

<blockquote>
  <ul>
  <li>如果对象中没有那个属性名，那么该属性就被扩充到该对象中。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>empty_obj.nickname = 'John';
empty_obj.nickname; //"John"

flight.equipment = {
    model: 'MH370'
};
flight.equipment.model;  //"MH370"
</code></pre>

<h3>引用</h3>

<blockquote>
  <ul>
  <li>对象通过引用来传递，永远不会被拷贝。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var x = empty_obj;  //将x赋值给empty_obj对象
x.hobby = 'movie';
var hob = empty_obj.hobby; //"movie"
//or var hob = x.hobby; //"movie"
</code></pre>

<blockquote>
  <ul>
  <li>x和empty<em>obj是指向同一个对象的引用，所以x.hobby 和 empty</em>obj.hobby为"movie"。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var a={},b={},c={};
//a、b和c都引用一个不同的空对象

a = b = c = {};
//a、b和c都是引用同一个空对象
</code></pre>

<h3>原型</h3>

<blockquote>
  <ul>
  <li>每个对象都连接到一个原型对象，并且它可以从中继承属性。</li>
  <li>所有通过对象字面量创建的对象都连接到Object.prototype这个JS中标准的对象。</li>
  <li>当你创建一个新对象时，可以选择某个对象作为它的原型。</li>
  <li>原型连接在更新时是不起作用的。当对某个对象做出改变时，不会触及到该对象的原型。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var stooge = {
    nickname: 'elly'
};
if(typeof Object.beget !== 'function'){
    Object.beget = function(o){
        var F = function(){};
        F.prototype = o;
        return new F();
    };
}

var another_stooge = Object.beget(stooge);
another_stooge.nickname = 'cm';
stooge.nickname; //"elly"
another_stooge.nickname;  //"cm"
</code></pre>

<blockquote>
  <ul>
  <li>原型连接只有在检索值的时候才被用到。</li>
  <li>如果我们尝试去获取对象的某个属性值，且该对象没有此属性名，那么JS会尝试从原型对象中获取属性值。</li>
  <li>如果那个原型对象也没有该属性，那么再从它的原型中寻找，依次类推，知道该过程最后到达终点Object.prototype。</li>
  <li>如果想要的属性完全不存在于原型链中，那么结果就是undefined。</li>
  <li>这个过程称为<strong>委托</strong></li>
  </ul>
</blockquote>

<p>上面那5句话第一次接触原型的朋友，应该不好理解，下面给个例子参考(PS:也是别人给我解释的，谢谢@basecss)：</p>

<pre><code>function Person(name,age) {
    this.name = name;
    this.age = age;
    //......
}
var useLess = new Person('useLess', 23);

// 注意下面
useLess.job; // undefined
// 首先 useLess 自身没有job属性
// 那就到 Person.prototype 中看看，还是没有
// 再到 Object 原型中找，还是没有
// 返回 undefined
useLess.toString(); // ['object Object']
// useLess 自己没有 toString() 方法
// 找它的原型 Person.prototype ，木有

最后到 Object.prototype 找到 toString() 方法
</code></pre>

<blockquote>
  <ul>
  <li>原型关系是一种动态的关系。</li>
  <li>如果我们添加一个新的属性在原型中，该属性会立即对所有基于该原型创建的对象可见。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>stooge.profession = 'actor';
another_stooge.profession; //'actor'
</code></pre>

<h3>反射</h3>

<blockquote>
  <ul>
  <li>检查对象并确定对象的属性，只要试着去检索该属性并验证取得的值。</li>
  <li>typeof可以确定属性的类型</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>typeof stooge.profession; //'string'
</code></pre>

<blockquote>
  <ul>
  <li>请务必注意，原型链中的任何属性也会产生一个值</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>typeof flight.toString; //'function'
typeof flight.constructor; //'function'
</code></pre>

<blockquote>
  <ul>
  <li>有两种方法处理这些不需要的属性
  <ul><li>第一个是让你的程序检查并剔除函数值</li>
  <li>第二个是使用hasOwnProperty方法。注意：如果对象拥有独有的属性，它将返回true。hasOwnProperty方法不会检查原型链</li></ul></li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>flight.hasOwnProperty('number');  //true
flight.hasOwnProperty('constructor'); //false
</code></pre>

<h3>枚举(for in)</h3>

<blockquote>
  <ul>
  <li>for in语句可用来遍历一个对象中的所有属性名。</li>
  <li>枚举过程将会列出所有的属性，包括函数和你可能不关心的原型中的属性,所以有必要多虑掉那些你不想要的值。</li>
  <li>最常用的过滤器是hasOwnProperty方法，以及使用typeof来排除函数。</li>
  </ul>
</blockquote>

<p>例如： </p>

<pre><code>var name;
for(name in another_stooge){
    if(typeof another_stooge[name] !== 'function'){
        document.writeln(name + ':' + another_stooge[name]);
    }
}
</code></pre>

<blockquote>
  <ul>
  <li>for in语句陈列出来的属性名顺序是不确定的，如果你想让属性名按顺序出现，最好的办法就是避免使用for in语句。</li>
  <li>而是创建一个数组，在其中以正确的顺序包含属性名。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var i;
var properties = {
    'first_name',
    'profession'

};
for(i = 0; i &lt; properties.length; i += 1){
    document.writeln(properties[i] + ':' + another_stooge[properties[i]]);
}
</code></pre>

<blockquote>
  <ul>
  <li>使用for,可以得到我们想要的属性，不用担心可能发掘出原型链中的属性，并且按顺序取得了它们的值。</li>
  </ul>
</blockquote>

<h3>删除(delete)</h3>

<blockquote>
  <ul>
  <li>delete运算符用来删除对象的属性，它不会触及原型链中的任何对象。</li>
  </ul>
</blockquote>

<pre><code>another_stooge.nickname; //'cm' 
delete another_stooge.nickname;
another_stooge.nickname; //暴露出原型中nickname属性。'elly'
</code></pre>

<h3>减少全局变量污染</h3>

<blockquote>
  <ul>
  <li>全局变量削弱程序的灵活性，所以尽量避免。</li>
  <li>最小化用全局变量的一个方法是在你的应用中只创建唯一一个全局变量。</li>
  </ul>
</blockquote>

<p>例如：</p>

<pre><code>var MYAPP = {};
//此时，全局变量已经变成了你的容器
MYAPP.stooge = {
    'first_name' : 'cm',
    'last_name' : 'liang'
};

MYAPP.flight = {
    'airline' : 'Oceanic',
};
</code></pre>

<blockquote>
  <ul>
  <li>只要把多个全局变量都整理在一个名称空间下，你将显著降低与其他应用程序、组件或类库之间产生糟糕的相互影响的可能性。</li>
  <li>你的程序也会变得更容易阅读。</li>
  </ul>
</blockquote>
        ]]>
      </description>
    </item>
    <item>
      <title>如何用toosolo建静态博客</title>
      <link>http://www.useLessblog.cn/article/toosolo.html</link>
      <guid isPermaLink="true">http://www.useLessblog.cn/article/toosolo.html</guid>
      <pubDate>Fri, 07 Mar 2014 00:00:00 +0800</pubDate>
      <description>
        <![CDATA[
        <p>在创建博客之前，你是不是忘了一件事呢？是的，你需要一个域名。你是不是现在立刻去万网之类的网站购买域名？先不要着急，这里提供两种方法给你选择，一种是你可以买了域名之后绑定到github page上面，就不需要去备案啥的。另一种是直接用github page上面的域名，例如：username.github.io。是不是不知道怎么操作，没事，你可以看 <a href="http://littledu.net/article/how-to-use-github.html">这里</a>。另外，建议你在买域名之前先看<a href="http://www.zhihu.com/question/20556410">这篇文章</a>。</p>

<p>言归正传，首先你先到<a href="https://github.com/TooBug/TooSolo">这里</a>了解Toosolo。是的，他里面也有教程，但是我还是要写这篇文章，至于问为什么，我也不知道。我只知道我写的唯一优势就是配了图说明。废话不多说，马上开始学习：</p>

<p>第一步：到<a href="http://nodejs.org/">node官网</a>下载node,然后安装。你是不是想问，为什么要安装node,很明显，你没有认真看github里面的内容。答案就是：<strong>Toosolo 是一个由Node构建的静态博客</strong>(PS：这一步就不配图详说了，有人跟我说，会装QQ的人都会装node。T^T)</p>

<p>第二步：安装Toosolo。</p>

<blockquote>
  <ul>
  <li><strong>windows + R</strong>输入<strong>cmd</strong>打开控制台;</li>
  <li>输入<strong>npm install -g toosolo</strong>执行命令。</li>
  <li>如果出现下图，恭喜你，说明你安装成功了！</li>
  </ul>
</blockquote>

<p><img src="/images/solo1.jpg" alt="Toosolo" title="" /></p>

<p>第三步：初始化Toosolo。</p>

<blockquote>
  <ul>
  <li>在你喜欢的磁盘中建个空文件夹;</li>
  <li>输入<strong>toosolo --init</strong> 或<strong> toosolo -i</strong>;</li>
  <li>如果你建的文件夹中有个source文件夹和config.json的文件，那么，恭喜你，初始化成功！</li>
  </ul>
</blockquote>

<p><img src="/images/solo2.jpg" alt="Toosolo" title="" /></p>

<p>初始化之后，里面文件夹及文件说明如下图：</p>

<p><img src="/images/solo3.jpg" alt="Toosolo" title="" /></p>

<p>第四步：编译toosolo。</p>

<blockquote>
  <ul>
  <li>在你每次修改toosolo里面的任何文件之后;</li>
  <li>定位到config.json所在的目录，然后执行toosolo这个命令;</li>
  <li>然后你会在你建的文件夹中看到一个dist文件夹</li>
  </ul>
</blockquote>

<p>额外知识：</p>

<pre><code>    D:  -&gt; 进入盘符
    dir  -&gt; 查看目录
    cd xxx -&gt; 进入 xxx 目录
    cd ../ -&gt; 回退到上层目录
</code></pre>

<p><img src="/images/solo4.jpg" alt="Toosolo" title="" /></p>

<p>第五步：然后在dist文件夹中打开index.html，就可以看到toosolo的模板了！</p>

<p>哈哈，执行到这里，就不用步骤形容了。</p>

<h3>接下来的问题是：如何将toosolo放到你的域名中展示呢？</h3>

<p>很简单，你只需将dist文件夹里面的文件复制你的空间中就行，然后修改config.json中的distPath。如图：</p>

<p><img src="/images/solo5.jpg" alt="Toosolo" title="" /></p>

<p>如果你是用github page的域名或是将你自己的域名绑定到github page，你可以按<a href="http://littledu.net/article/how-to-use-github.html">这里</a>的步骤去做。</p>

<p>注意，如果是将绑定自己的域名到github page，记得修改source/global/CNAME为自己的域名，不然每次commit的时候都会变回原来的。如图：</p>

<p><img src="/images/solo6.jpg" alt="Toosolo" title="" /></p>

<h3>看到这里，你是不是还有个疑问，如果我想改里面的排版或是样式要在哪里改？</h3>

<blockquote>
  <ul>
  <li>执行这个命令：<strong>toosolo --skin</strong>或是<strong>toosolo -s</strong>;</li>
  <li>你会在./source目录下看到有个skin的文件夹。</li>
  </ul>
</blockquote>

<p>如图：</p>

<p><img src="/images/solo7.jpg" alt="Toosolo" title="" /></p>

<p>skin里面文件夹介绍如图：</p>

<p><img src="/images/solo8.jpg" alt="Toosolo" title="" /></p>

<p>提醒：里面涉及到了使用jade。当然，要想发博客，你要先知道markdown（哈哈，这句貌似应该是在最前面提的，不管了）。你可以通过以下的链接进行了解：</p>

<blockquote>
  <ul>
  <li><p>了解markdown链接如下：
  <a href="https://www.zybuluo.com/mdeditor">https://www.zybuluo.com/mdeditor</a>
  <a href="http://wowubuntu.com/markdown/">http://wowubuntu.com/markdown/</a></p></li>
  <li><p>了解jade链接如下：
  <a href="http://naltatis.github.io/jade-syntax-docs/">http://naltatis.github.io/jade-syntax-docs/</a></p></li>
  </ul>
</blockquote>

<h3>还有一个问题，我要在哪里写我要发表的文章呢？</h3>

<p>看图说话：</p>

<p><img src="/images/solo9.jpg" alt="Toosolo" title="" /></p>

<h3>最后一个问题，页面上的图片要放在哪呢？图片怎么在本地看不到呢？</h3>

<blockquote>
  <ul>
  <li>页面上的图片放在/source/global/images目录下</li>
  <li>图片要推到外网之后才能看到，这个不用担心。</li>
  </ul>
</blockquote>

<p>哈哈，还有什么问题，可以在评论中提出来的哈。。。。。。</p>

<p>参考：</p>

<blockquote>
  <ul>
  <li><a href="https://github.com/TooBug/TooSolo">https://github.com/TooBug/TooSolo</a></li>
  <li><a href="https://github.com/TooBug/TooSolo/issues/17">https://github.com/TooBug/TooSolo/issues/17</a></li>
  <li><a href="https://github.com/TooBug/TooSolo/issues/21">https://github.com/TooBug/TooSolo/issues/21</a></li>
  </ul>
</blockquote>
        ]]>
      </description>
    </item>
  </channel>
</rss>